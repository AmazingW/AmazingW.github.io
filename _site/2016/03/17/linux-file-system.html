<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" /> <!--[if lte IE 9]><meta http-equiv="refresh" content="0;url=/ie.html"><![endif]--> <meta name="author" content=""> <meta name="keywords" content="linux,文件格式"> <title>Linux文件格式详解</title> <meta name="description" content="本文讨论了 UNIX/LINUX平台下三种主要的可执行文件格式：a.out（assembler and link editor output汇编器和链接编辑器的输出）、COFF（Common Object File Format 通用对象文件格式）、ELF（Executableand Linking Format..."> <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,400italic,600|Droid+Sans+Mono' rel='stylesheet' type='text/css'> <link rel="shortcut icon" href="/assets/img/favicon.jpg" /> <link rel="stylesheet" href="/css/main.css"> <link rel="canonical" href="http://amazingw.github.com/2016/03/17/linux-file-system.html"> <link rel="alternate" type="application/rss+xml" title="AW的个人博客" href="http://amazingw.github.com/pages/feed.xml" /> <script src="/assets/js/prefixfree.js"></script> </head> <body> <aside id="sidebar"> <div id="sidebar-left"> <a id="sidebar-avatar" href="/"> <img id="sidebar-avatar-img" alt="" src="/assets/icon/favicon.ico"/> </a> <div id="sidebar-social"> <a href="/pages/feed.xml" class="sidebar-social-icon feed"></a> <a href="mailto:wqf_525@live.cn" class="sidebar-social-icon email"></a> <a href="https://twitter.com/amazingw" class="sidebar-social-icon twitter" target="_blank"></a> <a href="https://github.com/amazingw" class="sidebar-social-icon github" target="_blank"></a> </div> <ul id="sidebar-tags"> <li class="sidebar-tag active" data-filter="all">全部文章</li> <li class="sidebar-tag" data-filter="服务端开发">服务端开发</li> <li class="sidebar-tag" data-filter="工具">工具</li> <li class="sidebar-tag" data-filter="资源">资源</li> <li class="sidebar-tag" data-filter="生活">生活</li> <li class="sidebar-tag" data-filter="客户端开发">客户端开发</li> <li class="sidebar-tag" data-filter="读书">读书</li> </ul> </div> <div id="sidebar-right"> <div id="search-box"> <input id="search-input" type="text" placeholder="Search" /> </div> <nav id="toc"> <a class="toc-link" data-tags="客户端开发" href="/2016/03/18/tableview-controls.html"> 类型化却不失灵活的 Table View Controller </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/18/swfit-server.html"> 服务端 Swift </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/18/from-swift-2-oc.html"> 从Objective-C到Swift </a> <a class="toc-link" data-tags="读书" href="/2016/03/18/book-list-of-2016.html"> 2016阅读书单 </a> <a class="toc-link" data-tags="工具" href="/2016/03/17/win7-service.html"> win7服务 </a> <a class="toc-link" data-tags="工具" href="/2016/03/17/issues-when-using-github.html"> github遇到问题及解决 </a> <a class="toc-link" data-tags="工具" href="/2016/03/17/error-of-cocopods.html"> cocopods 出现更新错误 </a> <a class="toc-link" data-tags="服务端开发" href="/2016/03/17/sql-use-of-explain.html"> mysql中explain用法详解 </a> <a class="toc-link" data-tags="服务端开发" href="/2016/03/17/sql-design.html"> 优化之查询语句优化 </a> <a class="toc-link" data-tags="服务端开发" href="/2016/03/17/server-design.html"> coc服务器设计图 </a> <a class="toc-link" data-tags="服务端开发" href="/2016/03/17/nodejs-deamon-fork.html"> nodejs守护进程的启动方法 </a> <a class="toc-link" data-tags="服务端开发" href="/2016/03/17/linux-file-system.html"> Linux文件格式详解 </a> <a class="toc-link" data-tags="服务端开发" href="/2016/03/17/knowledge-of-game-developper.html"> 游戏开发须知 </a> <a class="toc-link" data-tags="服务端开发" href="/2016/03/17/game-developper-code-desing.html"> 游戏设计规范要求 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/xcode-quickbutton.html"> xcode 快捷键 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/using-of-UIActivityIndicatorView.html"> UIActivityIndicatorView 的使用 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/use-of-vfl.html"> Autolayout中的Visual format language </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/use-of-rac.html"> IOS响应式编程框架ReactiveCocoa(RAC)使用示例 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/use-of-const.html"> C++ const 修饰方法注意事项 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/use-of-bundle.html"> 生成Bundle包-引入bundle-使用bundle </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/use-of-attribute-string.html"> NSAttributedString 常用方法 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/tabbar-zoom.html"> iOS，由于图片原因导致tabbar图片点击发生zoom的现象 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/symbol-not-found-for-architecture-armv7.html"> symbol(s) not found for architecture armv7 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/socket-develop-knowledge.html"> Socket网络通信框架 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/scrollview-experience.html"> UIScrollView 实践经验 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/runtime-main-point.html"> Objective C运行时（runtime）技术的几个要点总结 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/pop-experiences.html"> Pop上手体验 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/output-format.html"> NSLog 输出格式 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-useWifi.html"> iOS私有API之wifi扫描和wifi连接 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-useProtoBuffer.html"> iOS 从0使用protobuffer </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-use-NSInvocation.html"> iOS NSInvocation用法 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-use-ICONFONT.html"> 在iOS中使用icon font </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-use-GCDAsyncSocket.html"> 使用GCD AsyncSocket </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-static-librays.html"> OC静态库编辑问题 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-self-define-take-photo.html"> iOS 自定义拍照界面 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-pause-CALayer-Annimation.html"> iOS 如何暂停和恢复CALayer上的动画 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-multi-thread.html"> iOS多线程 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-Photo-memory.html"> iOS图片与内存 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-NSPredicate.html"> iOS 谓词查询NSPredicate </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-Image-Dealing.html"> iOS图片加水印或文字 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-Image-Crop-Graphics.html"> 图片裁剪 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-GCD-Thread.html"> OC线程类 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-Extension.html"> iOS开发者常用的10个Xcode插件 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-BlueTooth_develop.html"> iOS蓝牙4.0开发例子 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-Base-Knowledge.html"> iOS 开发的基本知识 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-Animations.html"> iOS 常用动画 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-Alpha-hidden-opaque.html"> iOS alpha hidden opaque </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-ActionSheet-problem.html"> UIActionSheet问题 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/hit-test-Event.html"> hitTest:withEvent:流程 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/forever-background-ios.html"> 无限后台测试代码 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/crashlog-from-dump.html"> 如何手动解析CrashLog </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/code-style-gnuc.html"> GNUC编码规范 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/c++-extern-detail.html"> C/C++中extern关键字详解 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/UITextInput-proto.html"> UITextInput协议参考 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/UITableViewCell-AutoHeight.html"> 动态计算UITableViewCell高度详解 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/RunTime-Swizzle.html"> Runtime替换方法 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/OtherLinkerFlags-iOS-XCode.html"> 关于Xcode的Other Linker Flags </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/Objc-API-Thread.html"> Objc的底层并发API </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/OC-Singleton.html"> oc 设计模式总结 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/LLVM-record.html"> LLVM操作记录 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/Facebook-Annimation2.html"> Facebook开源动画框架 Pop体验（二） </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/Facebook-Annimation1.html"> Facebook开源动画框架 Pop体验（一） </a> <a class="toc-link" data-tags="资源" href="/2015/10/04/general-vim-resources.html"> Vim 常用资源 </a> <a class="toc-link" data-tags="服务端开发" href="/2015/09/07/sort-algorithms.html"> 七种常见经典排序算法总结（C++实现） </a> <a class="toc-link" data-tags="资源" href="/2015/02/13/general-seo-resources.html"> SEO 常用资源 </a> <a class="toc-link" data-tags="工具" href="/2015/01/10/use-dropzone-and-qiniu-to-store-blog-images.html"> 使用Dropzone和七牛云存储来优化博客图床 </a> <a class="toc-link" data-tags="服务端开发" href="/2015/01/08/conflict-between-camel-and-snake-in-laravel.html"> Laravel 关联模型由于名称一致性导致的问题 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/12/06/ioc-and-facade-in-laravel.html"> Laravel 核心：控制反转（Inversion of Control）和门面模式（Facade） </a> <a class="toc-link" data-tags="服务端开发" href="/2014/09/26/use-old-version-of-brew-php.html"> 回退Mac上用Brew安装的PHP版本 </a> <a class="toc-link" data-tags="资源" href="/2014/08/03/general-mac-resources.html"> Mac 常用资源 </a> <a class="toc-link" data-tags="资源" href="/2014/05/11/general-mysql-resources.html"> MySQL常用资源 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/05/04/set-environment-variables-of-server-for-php.html"> 为PHP设置服务器(Apache/Nginx)环境变量 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/04/27/magic-methods-and-magic-constants-in-php.html"> PHP中的魔术方法和魔术常量简介和使用 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/04/23/roc-curve.html"> ROC曲线 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/04/19/design-patterns-of-php.html"> 设计模式详解及PHP实现 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/04/16/insert-large-number-of-data-in-mysql.html"> MySQL大量数据插入各种方法性能分析与比较 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/04/11/redis-queue-in-laravel.html"> Laravel中使用Redis作为队列系统的工作流程 </a> <a class="toc-link" data-tags="工具" href="/2014/04/10/install-vagrant-in-mac.html"> 在Mac下安装使用Vagrant </a> <a class="toc-link" data-tags="工具" href="/2014/04/10/install-docker-in-mac.html"> 在Mac下安装使用Docker </a> <a class="toc-link" data-tags="服务端开发" href="/2014/03/22/managing-your-larrvel-queue-by-supervisor.html"> 使用Supervisor来管理你的Laravel队列 </a> <a class="toc-link" data-tags="工具" href="/2014/03/20/php-debug-with-xdebug.html"> 用Xdebug和Sublime调试PHP代码 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/03/20/use-other-libraries-in-laravel.html"> 在Laravel中使用自己的类库三种方式 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/03/10/grunt-bower-and-laravel.html"> 用Laravel+Grunt+Bower管理你的应用 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/02/15/apache-and-nginx.html"> 从运行原理及使用场景看Apache和Nginx </a> <a class="toc-link" data-tags="工具" href="/2014/02/12/how-to-deploy-a-blog-on-github-by-jekyll.html"> 在Github上搭建Jekyll博客和创建主题 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/01/30/understanding-the-github-workflow.html"> 了解GitHub工作流【译】 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/01/25/how-to-use-php-socket.html"> PHP Socket的使用 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/01/24/apache-log-format.html"> Apache 日志文件格式及简单处理 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/01/17/python-script-of-sae-log-download.html"> Python脚本--下载合并SAE日志 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/01/16/php-namespace-and-autoload.html"> PHP命名空间及自动加载 </a> <a class="toc-link" data-tags="资源" href="/2014/01/15/general-svn-resources.html"> SVN 常用资源 </a> <a class="toc-link" data-tags="资源" href="/2014/01/15/general-shell-resources.html"> Shell 常用资源 </a> <a class="toc-link" data-tags="资源" href="/2014/01/15/general-python-resources.html"> Python 常用资源 </a> <a class="toc-link" data-tags="资源" href="/2014/01/15/general-php-resources.html"> PHP 常用资源 </a> <a class="toc-link" data-tags="资源" href="/2014/01/15/general-jquery-resources.html"> jQuery 常用资源 </a> <a class="toc-link" data-tags="资源" href="/2014/01/15/general-javascript-resources.html"> JavaScript 常用资源 </a> <a class="toc-link" data-tags="资源" href="/2014/01/15/general-html-resources.html"> HTML 常用资源 </a> <a class="toc-link" data-tags="资源" href="/2014/01/15/general-git-resources.html"> Git 常用资源 </a> <a class="toc-link" data-tags="工具" href="/2013/12/11/lamp-in-mac.html"> Mac下用brew搭建PHP(LNMP/LAMP)开发环境 </a> <a class="toc-link" data-tags="工具" href="/2013/12/11/deploy-pptp-vpn-in-ubuntu.html"> 在ubuntu下搭建pptp vpn服务器 </a> <a class="toc-link" data-tags="工具" href="/2013/12/08/linux-command-continue.html"> Linux下多个命令连续执行方法 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/12/08/implemention-of-breadcrumbs-by-css3.html"> 基于CSS3实现尖角面包屑 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/10/01/deploy-ceilometer-of-openstack.html"> 部署Ceilometer到已有环境中 </a> <a class="toc-link" data-tags="工具" href="/2013/08/28/change-bootstrap-to-3.html"> 更新前端框架到Bootstrap3 </a> <a class="toc-link" data-tags="工具" href="/2013/08/06/tools-of-reading.html"> 我与工具--阅读和知识管理 </a> <a class="toc-link" data-tags="生活" href="/2013/08/01/program-and-life.html"> 关于效率、程序与生活的一些思考 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/06/12/hacking-in-openstack-ceilometer-collector.html"> OpenStack Ceilometer Collector代码解读 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/06/12/hacking-in-openstack-ceilometer-api.html"> OpenStack Ceilometer数据存储与API源码解析 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/06/11/pipeline-of-openstack-ceilometer.html"> OpenStack Ceilometer中的Pipeline机制 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/06/11/hacking-in-openstack-ceilometer-compute-agent.html"> OpenStack Ceilometer Compute Agent源码解读 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/06/09/learn-python-stevedore-module-in-detail.html"> 学习Python动态扩展包stevedore </a> <a class="toc-link" data-tags="服务端开发" href="/2013/06/09/learn-python-abc-module.html"> 学习Python的ABC模块 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/06/07/learn-python-setuptools-in-detail.html"> Python包管理工具setuptools详解 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/05/27/openstack-horizon-locale.html"> OpenStack Horizon 中文本地化 </a> <a class="toc-link" data-tags="工具" href="/2013/05/23/install-mysql-and-mongo-web-admin.html"> 安装MySQL和MongoDB的WEB管理界面 </a> <a class="toc-link" data-tags="工具" href="/2013/05/22/change-to-zsh.html"> 从Bash切换到Zsh </a> <a class="toc-link" data-tags="工具" href="/2013/05/20/set-proxy-for-git-or-apt.html"> 给Git或者APT设置goagent代理 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/05/19/what-is-wsgi.html"> WSGI学习 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/05/16/deploy-openstack-grizzly-in-virtual-machine.html"> 在虚拟机单机部署OpenStack Grizzly </a> <a class="toc-link" data-tags="服务端开发" href="/2013/05/15/learn-how-to-use-distutils.html"> 学习使用python打包工具distutils </a> <a class="toc-link" data-tags="服务端开发" href="/2013/05/15/different-between-python-package-tools.html"> python包工具之间的关系 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/05/15/create-ubuntu-image-for-openstack.html"> 给OpenStack创建Ubuntu镜像 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/05/13/openstack-grizzly-multihost-deployment-doc.html"> OpenStack Grizzly Multihost部署文档 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/05/06/why-use-pip-over-easy-install.html"> 为什么使用pip而不是easy_install </a> <a class="toc-link" data-tags="服务端开发" href="/2013/05/06/the-viewpoint-metatag.html"> HTML中meta标签viewpoint的作用 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/05/06/interactive-coding-ipython.html"> 交互式编程-IPython </a> <a class="toc-link" data-tags="服务端开发" href="/2013/05/03/php-cache-of-a-page.html"> 页面提速之——数据缓存 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/05/03/create-windows-7-image-for-openstack.html"> 给OpenStack创建Win7镜像 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/05/01/terminal-command-of-ceilometer.html"> Ceilometer的命令行使用 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/05/01/deploy-a-ceilometer-horizon-project.html"> 部署一个ceilometer-horizon项目 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/04/26/create-windows-xp-image-for-openstack.html"> 给OpenStack创建Windows XP镜像 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/04/25/some-concept-about-enterprise-storage.html"> 几种企业的存储系统 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/04/25/conceptual-logical-physical.html"> 概念模型、逻辑模型、物理模型的区别 </a> <a class="toc-link" data-tags="工具" href="/2013/04/23/deploy-jeklly-blog.html"> 在GitHub上搭建自己的Jekyll博客--了解环境 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/04/23/opensource-licenses.html"> 五中常见的开源协议整理(BSD,Apache,GPL,LGPL,MIT) </a> <a class="toc-link" data-tags="资源" href="/2013/04/23/general-bootstrap-resources.html"> Bootstrap常用资源 </a> <a class="toc-link" data-tags="工具" href="/2013/04/22/wordpress-to-jekyll.html"> 博客迁移完成 </a> <a class="toc-link" data-tags="工具" href="/2013/04/22/ignore-password-in-git-push.html"> 让git push命令不再需要密码 </a> <a class="toc-link" data-tags="工具" href="/2013/04/22/highlight-of-jekyll.html"> Jekyll的中的代码高亮 </a> <a class="toc-link" data-tags="工具" href="/2013/04/22/add-svn-ignore-file.html"> 给SVN控制的项目添加忽略文件/文件夹 </a> <a class="toc-link" data-tags="工具" href="/2013/04/21/add-snippet.html"> 给sublime增加snippet </a> <a class="toc-link" data-tags="服务端开发" href="/2013/03/27/glossary-of-ceilometer.html"> OpenStack监控项目Ceilometer的一些术语 </a> <a class="toc-link" data-tags="工具" href="/2013/03/25/tools-of-sever-deployment.html"> 服务器自动化部署及运维常见工具 </a> <a class="toc-link" data-tags="工具" href="/2013/03/25/open-tcp-port-of-libvirt.html"> Linux下开启Libvirtd的tcp监控 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/03/21/vnc-vs-rdp.html"> VNC和远程桌面的区别 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/03/21/introduction-of-ceilometer.html"> OpenStack Ceilometer项目简介 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/03/20/different-bewteen-kvm-xen-qemu.html"> 虚拟化与云计算中KVM,Xen,Qemu的区别和联系 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/03/20/debug-and-modify-openstack-horizon.html"> 调试和修改OpenStack中的Horizon部分 </a> <a class="toc-link" data-tags="工具" href="/2013/02/25/quick-open-in-windows.html"> win7快速打开应用程序或文件 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/02/24/javascript-variable-domain.html"> JavaScript变量作用域 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/01/30/introduction-of-kanyun-worker.html"> kanyun worker原理 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/01/30/introduction-kanyun-server.html"> kanyun server服务 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/01/30/deploy-kanyun.html"> 在OpenStack中部署kanyun </a> <a class="toc-link" data-tags="服务端开发" href="/2013/01/30/command-of-kanyun.html"> kanyun的api-client命令 </a> <a class="toc-link" data-tags="工具" href="/2013/01/16/create-remote-resp.html"> git创建远程库 </a> <a class="toc-link" data-tags="工具" href="/2013/01/09/remote-access-of-mysql.html"> MySQL远程访问 </a> <a class="toc-link" data-tags="服务端开发" href="/2012/12/31/python-development-of-sae.html"> sae下的python开发部署和一个简单例子 </a> <a class="toc-link" data-tags="工具" href="/2012/12/30/share-windows-and-linux.html"> Windows和Linux切换最终解决方案 </a> <a class="toc-link" data-tags="服务端开发" href="/2012/11/08/openstack-nova-internal.html"> OpenStack Nova内部机制【译】 </a> <a class="toc-link" data-tags="服务端开发" href="/2012/09/27/php-variable-variables.html"> PHP可变变量 </a> <a class="toc-link" data-tags="服务端开发" href="/2012/09/27/open-widown-in-javascript.html"> JS中防止浏览器屏蔽window.open </a> <a class="toc-link" data-tags="服务端开发" href="/2012/09/19/php-session-security.html"> PHP操作Session的原理及提升安全性时的一个问题 </a> </nav> </div> </aside> <main id="main"> <article class="post container"> <div class="post-meta"> <span class="post-meta-span date">2016 March 17</span> <span class="post-meta-span tag">linux</span> </div> <h1 class="post-title">Linux文件格式详解</h1> <p>本文讨论了 UNIX/LINUX平台下三种主要的可执行文件格式：a.out（assembler and link editor output汇编器和链接编辑器的输出）、COFF（Common Object File Format 通用对象文件格式）、ELF（Executableand Linking Format 可执行和链接格式）。首先是对可执行文件格式的一个综述，并通过描述 ELF文件加载过程以揭示可执行文件内容与加载运行操作之间的关系。随后依此讨论了此三种文件格式，并着重讨论 ELF文件的动态连接机制，其间也穿插了对各种文件格式优缺点的评价。最后对三种可执行文件格式有一个简单总结，并提出作者对可文件格式评价的一些感想。</p> <p>可执行文件格式综述 相对于其它文件类型，可执行文件可能是一个操作系统中最重要的文件类型，因为它们是完成操作的真正执行者。可执行文件的大小、运行速度、资源占用情况以及可扩展性、可移植性等与文件格式的定义和文件加载过程紧密相关。研究可执行文件的格式对编写高性能程序和一些黑客技术的运用都是非常有意义的。</p> <p>不 管何种可执行文件格式，一些基本的要素是必须的，显而易见的，文件中应包含代码和数据。因为文件可能引用外部文件定义的符号（变量和函数），因此重定位信 息和符号信息也是需要的。一些辅助信息是可选的，如调试信息、硬件信息等。基本上任意一种可执行文件格式都是按区间保存上述信息，称为段 （Segment）或节（Section）。不同的文件格式中段和节的含义可能有细微区别，但根据上下文关系可以很清楚的理解，这不是关键问题。最后，可 执行文件通常都有一个文件头部以描述本文件的总体结构。</p> <p>相对可执 行文件有三个重要的概念：编译（compile）、连接（link，也可称为链接、联接）、加载（load）。源程序文件被编译成目标文件，多个目标文件 被连接成一个最终的可执行文件，可执行文件被加载到内存中运行。因为本文重点是讨论可执行文件格式，因此加载过程也相对重点讨论。下面是LINUX平台下 ELF文件加载过程的一个简单描述。</p> <p>1：内核首先读ELF文件的 头部，然后根据头部的数据指示分别读入各种数据结构，找到标记为可加载（loadable）的段，并调用函数 mmap()把段内容加载到内存中。在加载之前，内核把段的标记直接传递给mmap()，段的标记指示该段在内存中是否可读、可写，可执行。显然，文本段 是只读可执行，而数据段是可读可写。这种方式是利用了现代操作系统和处理器对内存的保护功能。著名的Shellcode（参考资料 17）的编写技巧则是突破此保护功能的一个实际例子。</p> <p>2：内核分析出ELF文件标记为 PT_INTERP 的段中所对应的动态连接器名称，并加载动态连接器。现代 LINUX 系统的动态连接器通常是 /lib/ld-linux.so.2，相关细节在后面有详细描述。</p> <p>3：内核在新进程的堆栈中设置一些标记-值对，以指示动态连接器的相关操作。</p> <p>4：内核把控制传递给动态连接器。</p> <p>5：动态连接器检查程序对外部文件（共享库）的依赖性，并在需要时对其进行加载。</p> <p>6：动态连接器对程序的外部引用进行重定位，通俗的讲，就是告诉程序其引用的外部变量/函数的地址，此地址位于共享库被加载在内存的区间内。动态连接还有一个延迟（Lazy）定位的特性，即只在”真正”需要引用符号时才重定位，这对提高程序运行效率有极大帮助。</p> <p>7：动态连接器执行在ELF文件中标记为 .init 的节的代码，进行程序运行的初始化。在早期系统中，初始化代码对应函数 _init(void)(函数名强制固定)，在现代系统中，则对应形式为</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">__attribute</span><span class="p">((</span><span class="n">constructor</span><span class="p">))</span>
<span class="n">init_function</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="err">……</span>
<span class="p">}</span>
</code></pre></div> <p>其中函数名为任意。</p> <p>8：动态连接器把控制传递给程序，从 ELF 文件头部中定义的程序进入点开始执行。在 a.out 格式和ELF格式中，程序进入点的值是显式存在的，在 COFF 格式中则是由规范隐含定义。</p> <p>从 上面的描述可以看出，加载文件最重要的是完成两件事情：加载程序段和数据段到内存；进行外部定义符号的重定位。重定位是程序连接中一个重要概念。我们知 道，一个可执行程序通常是由一个含有 main()的主程序文件、若干目标文件、若干共享库（Shared Libraries）组成。（注：采用一些特别的技巧，也可编写没有 main函数的程序，请参阅参考资料 2）一个 C程序可能引用共享库定义的变量或函数，换句话说就是程序运行时必须知道这些变量/函数的地址。在静态连接中，程序所有需要使用的外部定义都完全包含在可 执行程序中，而动态连接则只在可执行文件中设置相关外部定义的一些引用信息，真正的重定位是在程序运行之时。静态连接方式有两个大问题：如果库中变量或函 数有任何变化都必须重新编译连接程序；如果多个程序引用同样的变量/函数，则此变量/函数会在文件/内存中出现多次，浪费硬盘/内存空间。比较两种连接方 式生成的可执行文件的大小，可以看出有明显的区别。</p> <p>a.out 文件格式分析 a.out 格式在不同的机器平台和不同的 UNIX 操作系统上有轻微的不同，例如在 MC680x0 平台上有 6 个 section。下面我们讨论的是最”标准”的格式。</p> <p>a.out 文件包含 7 个 section，格式如下： exec header（执行头部，也可理解为文件头部） text segment（文本段） data segment(数据段) text relocations(文本重定位段) data relocations（数据重定位段） symbol table（符号表） string table（字符串表）</p> <p>执行头部的数据结构：</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">exec</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">a_midmag</span><span class="p">;</span>    <span class="cm">/* 魔数和其它信息 */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">a_text</span><span class="p">;</span>      <span class="cm">/* 文本段的长度 */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">a_data</span><span class="p">;</span>      <span class="cm">/* 数据段的长度 */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">a_bss</span><span class="p">;</span>       <span class="cm">/* BSS段的长度 */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">a_syms</span><span class="p">;</span>      <span class="cm">/* 符号表的长度 */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">a_entry</span><span class="p">;</span>     <span class="cm">/* 程序进入点 */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">a_trsize</span><span class="p">;</span>    <span class="cm">/* 文本重定位表的长度 */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>   <span class="n">a_drsize</span><span class="p">;</span>    <span class="cm">/* 数据重定位表的长度 */</span>
<span class="p">};</span>
</code></pre></div> <p>文 件头部主要描述了各个 section 的长度，比较重要的字段是a_entry（程序进入点），代表了系统在加载程序并初试化各种环境后开始执行程序代码的入口。这个字段在后面讨论的 ELF文件头部中也有出现。由 a.out 格式和头部数据结构我们可以看出，a.out的格式非常紧凑，只包含了程序运行所必须的信息（文本、数据、BSS），而且每个 section的顺序是固定的。这种结构缺乏扩展性，如不能包含”现代”可执行文件中常见的调试信息，最初的 UNIX 黑客对 a.out 文件调试使用的工具是adb，而 adb 是一种机器语言调试器！</p> <p>a.out 文件中包含符号表和两个重定位表，这三个表的内容在连接目标文件以生成可执行文件时起作用。在最终可执行的 a.out 文件中，这三个表的长度都为0。a.out文件在连接时就把所有外部定义包含在可执行程序中，如果从程序设计的角度来看，这是一种硬编码方式，或者可称为 模块之间是强藕和的。在后面的讨论中，我们将会具体看到ELF格式和动态连接机制是如何对此进行改进的。</p> <p>a.out 是早期UNIX系统使用的可执行文件格式，由 AT&amp;T设计，现在基本上已被 ELF 文件格式代替。a.out 的设计比较简单，但其设计思想明显的被后续的可执行文件格式所继承和发扬。可以参阅参考资料16 和阅读参考资料 15 源代码加深对 a.out 格式的理解。参考资料 12 讨论了如何在”现代”的红帽LINUX运行 a.out格式文件。</p> <p>COFF 文件格式分析 COFF 格式比 a.out 格式要复杂一些，最重要的是包含一个节段表(section table)，因此除了 .text，.data，和 .bss 区段以外，还可以包含其它的区段。另外也多了一个可选的头部，不同的操作系统可一对此头部做特定的定义。</p> <p>COFF 文件格式如下： File Header(文件头部) Optional Header(可选文件头部) Section 1 Header(节头部) ……… Section n Header(节头部) Raw Data for Section 1(节数据) Raw Data for Section n(节数据) Relocation Info for Sect. 1(节重定位数据) Relocation Info for Sect. n(节重定位数据) Line Numbers for Sect. 1(节行号数据) Line Numbers for Sect. n(节行号数据) Symbol table(符号表) String table(字符串表)</p> <p>文件头部的数据结构：</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">filehdr</span>
   <span class="p">{</span>
     <span class="kt">unsigned</span> <span class="kt">short</span>  <span class="n">f_magic</span><span class="p">;</span>    <span class="cm">/* 魔数 */</span>
       <span class="kt">unsigned</span> <span class="kt">short</span>  <span class="n">f_nscns</span><span class="p">;</span>    <span class="cm">/* 节个数 */</span>
       <span class="kt">long</span>            <span class="n">f_timdat</span><span class="p">;</span>   <span class="cm">/* 文件建立时间 */</span>
       <span class="kt">long</span>            <span class="n">f_symptr</span><span class="p">;</span>   <span class="cm">/* 符号表相对文件的偏移量 */</span>
       <span class="kt">long</span>            <span class="n">f_nsyms</span><span class="p">;</span>    <span class="cm">/* 符号表条目个数 */</span>
       <span class="kt">unsigned</span> <span class="kt">short</span>  <span class="n">f_opthdr</span><span class="p">;</span>   <span class="cm">/* 可选头部长度 */</span>
       <span class="kt">unsigned</span> <span class="kt">short</span>  <span class="n">f_flags</span><span class="p">;</span>    <span class="cm">/* 标志 */</span>
   <span class="p">};</span>
</code></pre></div> <p>COFF 文件头部中魔数与其它两种格式的意义不太一样，它是表示针对的机器类型，例如 0x014c 相对于 I386 平台，而 0x268 相对于Motorola 68000系列等。当 COFF 文件为可执行文件时，字段 f_flags 的值为F_EXEC（0X00002），同时也表示此文件没有未解析的符号，换句话说，也就是重定位在连接时就已经完成。由此也可以看出，原始的 COFF格式不支持动态连接。为了解决这个问题以及增加一些新的特性，一些操作系统对 COFF 格式进行了扩展。Microsoft 设计了名为PE（Portable Executable）的文件格式，主要扩展是在 COFF 文件头部之上增加了一些专用头部，具体细节请参阅参考资料18，某些 UNIX 系统也对 COFF 格式进行了扩展，如 XCOFF（extended common object fileformat）格式，支持动态连接，请参阅参考资料 5。</p> <p>紧接文件头部的是可选头部，COFF 文件格式规范中规定可选头部的长度可以为 0，但在 LINUX 系统下可选头部是必须存在的。下面是 LINUX 下可选头部的数据结构：</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="kt">char</span>   <span class="n">magic</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>    <span class="cm">/* 魔数 */</span>
    <span class="kt">char</span>   <span class="n">vstamp</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>    <span class="cm">/* 版本号 */</span>
    <span class="kt">char</span>   <span class="n">tsize</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>    <span class="cm">/* 文本段长度 */</span>
    <span class="kt">char</span>   <span class="n">dsize</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>    <span class="cm">/* 已初始化数据段长度 */</span>
    <span class="kt">char</span>   <span class="n">bsize</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>    <span class="cm">/* 未初始化数据段长度 */</span>
    <span class="kt">char</span>   <span class="n">entry</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>    <span class="cm">/* 程序进入点 */</span>
    <span class="kt">char</span>   <span class="n">text_start</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>       <span class="cm">/* 文本段基地址 */</span>
    <span class="kt">char</span>   <span class="n">data_start</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>       <span class="cm">/* 数据段基地址 */</span>
<span class="p">}</span>
<span class="n">COFF_AOUTHDR</span><span class="p">;</span>
</code></pre></div> <p>字段 magic 为 0413 时表示 COFF 文件是可执行的，注意到可选头部中显式定义了程序进入点，标准的 COFF 文件没有明确的定义程序进入点的值，通常是从 .text 节开始执行，但这种设计并不好。</p> <p>前 面我们提到，COFF 格式比 a.out格式多了一个节段表，一个节头条目描述一个节数据的细节，因此 COFF 格式能包含更多的节，或者说可以根据实际需要，增加特定的节，具体表现在COFF 格式本身的定义以及稍早提及的 COFF 格式扩展。我个人认为，节段表的出现可能是 COFF 格式相对 a.out格式最大的进步。下面我们将简单描述 COFF文件中节的数据结构，因为节的意义更多体现在程序的编译和连接上，所以本文不对其做更多的描述。此外，ELF 格式和COFF格式对节的定义非常相似，在随后的 ELF 格式分析中，我们将省略相关讨论。</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">COFF_scnhdr</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">s_name</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>     <span class="cm">/* 节名称 */</span>
    <span class="kt">char</span> <span class="n">s_paddr</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>    <span class="cm">/* 物理地址 */</span>
   <span class="kt">char</span> <span class="n">s_vaddr</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>    <span class="cm">/* 虚拟地址 */</span>
    <span class="kt">char</span> <span class="n">s_size</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>     <span class="cm">/* 节长度 */</span>
   <span class="kt">char</span> <span class="n">s_scnptr</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>    <span class="cm">/* 节数据相对文件的偏移量 */</span>
    <span class="kt">char</span> <span class="n">s_relptr</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>    <span class="cm">/* 节重定位信息偏移量 */</span>
    <span class="kt">char</span> <span class="n">s_lnnoptr</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>    <span class="cm">/* 节行信息偏移量 */</span>
    <span class="kt">char</span> <span class="n">s_nreloc</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>    <span class="cm">/* 节重定位条目数 */</span>
    <span class="kt">char</span> <span class="n">s_nlnno</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>    <span class="cm">/* 节行信息条目数 */</span>
    <span class="kt">char</span> <span class="n">s_flags</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>    <span class="cm">/* 段标记 */</span>
<span class="p">};</span>
</code></pre></div> <p>有 一点需要注意：LINUX系统中头文件coff.h中对字段s_paddr的注释是”physicaladdress”，但似乎应该理解为”节被加载到内 存中所占用的空间长度”。字段s_flags标记该节的类型，如文本段、数据段、BSS段等。在COFF的节中也出现了行信息，行信息描述了二进制代码与 源代码的行号之间的对映关系，在调试时很有用。</p> <p>参考资料 19是一份对COFF格式详细描述的中文资料，更详细的内容请参阅参考资料 20。</p> <p>ELF文件格式分析 ELF 文件有三种类型：可重定位文件：也就是通常称的目标文件，后缀为.o。共享文件：也就是通常称的库文件，后缀为.so。可执行文件：本文主要讨论的文件格 式，总的来说，可执行文件的格式与上述两种文件的格式之间的区别主要在于观察的角度不同：一种称为连接视图（Linking View），一种称为执行视图（Execution View）。</p> <p>首先看看ELF文件的总体布局： ELF header(ELF头部) Program header table(程序头表) Segment1（段1） Segment2（段2） ……… Sengmentn（段n） Setion header table(节头表，可选)</p> <p>段 由若干个节(Section)构成,节头表对每一个节的信息有相关描述。对可执行程序而言，节头表是可选的。参考资料 1中作者谈到把节头表的所有数据全部设置为0，程序也能正确运行！ELF头部是一个关于本文件的路线图（roadmap），从总体上描述文件的结构。下面 是ELF头部的数据结构：</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">e_ident</span><span class="p">[</span><span class="n">EI_NIDENT</span><span class="p">];</span>     <span class="cm">/* 魔数和相关信息 */</span>
    <span class="n">Elf32_Half</span>    <span class="n">e_type</span><span class="p">;</span>                 <span class="cm">/* 目标文件类型 */</span>
    <span class="n">Elf32_Half</span>    <span class="n">e_machine</span><span class="p">;</span>              <span class="cm">/* 硬件体系 */</span>
    <span class="n">Elf32_Word</span>    <span class="n">e_version</span><span class="p">;</span>              <span class="cm">/* 目标文件版本 */</span>
    <span class="n">Elf32_Addr</span>    <span class="n">e_entry</span><span class="p">;</span>                <span class="cm">/* 程序进入点 */</span>
    <span class="n">Elf32_Off</span>     <span class="n">e_phoff</span><span class="p">;</span>                <span class="cm">/* 程序头部偏移量 */</span>
    <span class="n">Elf32_Off</span>     <span class="n">e_shoff</span><span class="p">;</span>                <span class="cm">/* 节头部偏移量 */</span>
    <span class="n">Elf32_Word</span>    <span class="n">e_flags</span><span class="p">;</span>                <span class="cm">/* 处理器特定标志 */</span>
    <span class="n">Elf32_Half</span>    <span class="n">e_ehsize</span><span class="p">;</span>               <span class="cm">/* ELF头部长度 */</span>
    <span class="n">Elf32_Half</span>    <span class="n">e_phentsize</span><span class="p">;</span>            <span class="cm">/* 程序头部中一个条目的长度 */</span>
    <span class="n">Elf32_Half</span>    <span class="n">e_phnum</span><span class="p">;</span>                <span class="cm">/* 程序头部条目个数  */</span>
    <span class="n">Elf32_Half</span>    <span class="n">e_shentsize</span><span class="p">;</span>            <span class="cm">/* 节头部中一个条目的长度 */</span>
    <span class="n">Elf32_Half</span>    <span class="n">e_shnum</span><span class="p">;</span>                <span class="cm">/* 节头部条目个数 */</span>
    <span class="n">Elf32_Half</span>    <span class="n">e_shstrndx</span><span class="p">;</span>             <span class="cm">/* 节头部字符表索引 */</span>
<span class="p">}</span> <span class="n">Elf32_Ehdr</span><span class="p">;</span>
</code></pre></div> <p>下面我们对ELF头表中一些重要的字段作出相关说明，完整的ELF定义请参阅参考资料 6和参考资料7。</p> <p>e_ident[0]-e_ident[3] 包含了ELF文件的魔数，依次是0x7f、’E’、’L’、’F’。注意，任何一个ELF文件必须包含此魔数。参考资料3中讨论了利用程序、工具、 /Proc文件系统等多种查看ELF魔数的方法。e_ident[4]表示硬件系统的位数，1代表32位，2代表64位。e_ident[5]表示数据编 码方式，1代表小印第安排序（最大有意义的字节占有最低的地址），2代表大印第安排序（最大有意义的字节占有最高的地址）。e_ident[6]指定 ELF头部的版本，当前必须为1。e_ident[7]到e_ident[14]是填充符，通常是0。ELF格式规范中定义这几个字节是被忽略的，但实际 上是这几个字节完全可以可被利用。如病毒Lin/Glaurung.676/666（参考资料1）设置e_ident[7]为0x21,表示本文件已被感染；或者存放可执行代码（参考资料2）。ELF头部中大多数字段都是对子头部数据的描述，其意义相对比较简单。值得注意的是某些病毒可能修改字段e_entry（程序进入点）的值，以指向病毒代码，例如上面提到的病毒Lin/Glaurung.676/666。</p> <p>一个实际可执行文件的文件头部形式如下：（利用命令readelf）</p> <div class="highlighter-rouge"><pre class="highlight"><code>   ELF Header:
   Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
   Class:                             ELF32
   Data:                              2<span class="s1">'s complement, little endian
   Version:                           1 (current)
   OS/ABI:                            UNIX - System V
   ABI Version:                       0
   Type:                              EXEC (Executable file)
   Machine:                           Intel 80386
   Version:                           0x1
   Entry point address:               0x80483cc
   Start of program headers:          52 (bytes into file)
   Start of section headers:          14936 (bytes into file)
   Flags:                             0x0
   Size of this header:               52 (bytes)
   Size of program headers:           32 (bytes)
   Number of program headers:         6
   Size of section headers:           40 (bytes)
   Number of section headers:         34
   Section header string table index: 31
</span></code></pre></div> <p>紧接ELF头部的是程序头表，它是一个结构数组，包含了ELF头表中字段e_phnum定义的条目，结构描述一个段或其他系统准备执行该程序所需要的信息。</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
      <span class="n">Elf32_Word</span>  <span class="n">p_type</span><span class="p">;</span>    <span class="cm">/* 段类型 */</span>
      <span class="n">Elf32_Off</span>   <span class="n">p_offset</span><span class="p">;</span>        <span class="cm">/* 段位置相对于文件开始处的偏移量 */</span>
      <span class="n">Elf32_Addr</span>  <span class="n">p_vaddr</span><span class="p">;</span>      <span class="cm">/* 段在内存中的地址 */</span>
      <span class="n">Elf32_Addr</span>  <span class="n">p_paddr</span><span class="p">;</span>      <span class="cm">/* 段的物理地址 */</span>
      <span class="n">Elf32_Word</span>  <span class="n">p_filesz</span><span class="p">;</span>    <span class="cm">/* 段在文件中的长度 */</span>
      <span class="n">Elf32_Word</span>  <span class="n">p_memsz</span><span class="p">;</span>    <span class="cm">/* 段在内存中的长度 */</span>
      <span class="n">Elf32_Word</span>  <span class="n">p_flags</span><span class="p">;</span>    <span class="cm">/* 段的标记 */</span>
      <span class="n">Elf32_Word</span>  <span class="n">p_align</span><span class="p">;</span>    <span class="cm">/* 段在内存中对齐标记 */</span>
  <span class="p">}</span> <span class="n">Elf32_Phdr</span><span class="p">;</span>
</code></pre></div> <p>在详细讨论可执行文件程序头表之前，首先查看一个实际文件的输出：</p> <div class="highlighter-rouge"><pre class="highlight"><code>  Program Headers:
Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
PHDR           0x000034 0x08048034 0x08048034 0x000c0 0x000c0 R E 0x4
INTERP         0x0000f4 0x080480f4 0x080480f4 0x00013 0x00013 R   0x1
      <span class="o">[</span>Requesting program interpreter: /lib/ld-linux.so.2]
   LOAD           0x000000 0x08048000 0x08048000 0x00684 0x00684 R E 0x1000
   LOAD           0x000684 0x08049684 0x08049684 0x00118 0x00130 RW  0x1000
   DYNAMIC        0x000690 0x08049690 0x08049690 0x000c8 0x000c8 RW  0x4
   NOTE           0x000108 0x08048108 0x08048108 0x00020 0x00020 R   0x4
</code></pre></div> <div class="highlighter-rouge"><pre class="highlight"><code>  Section to Segment mapping:
  Segment Sections...
   00
   01     .interp
   02     .interp .note.ABI-tag .hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame
   03     .data .dynamic .ctors .dtors .jcr .got .bss
   04     .dynamic
   05     .note.ABI-tag
</code></pre></div> <div class="highlighter-rouge"><pre class="highlight"><code>Section Headers:
  <span class="o">[</span>Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  <span class="o">[</span> 0]                   NULL            00000000 000000 000000 00      0   0  0
  <span class="o">[</span> 1] .interp           PROGBITS        080480f4 0000f4 000013 00   A  0   0  1
  <span class="o">[</span> 2] .note.ABI-tag     NOTE            08048108 000108 000020 00   A  0   0  4
  <span class="o">[</span> 3] .hash             HASH            08048128 000128 000040 04   A  4   0  4
  <span class="o">[</span> 4] .dynsym           DYNSYM          08048168 000168 0000b0 10   A  5   1  4
  <span class="o">[</span> 5] .dynstr           STRTAB          08048218 000218 00007b 00   A  0   0  1
  <span class="o">[</span> 6] .gnu.version      VERSYM          08048294 000294 000016 02   A  4   0  2
  <span class="o">[</span> 7] .gnu.version_r    VERNEED         080482ac 0002ac 000030 00   A  5   1  4
  <span class="o">[</span> 8] .rel.dyn          REL             080482dc 0002dc 000008 08   A  4   0  4
  <span class="o">[</span> 9] .rel.plt          REL             080482e4 0002e4 000040 08   A  4   b  4
  <span class="o">[</span>10] .init             PROGBITS        08048324 000324 000017 00  AX  0   0  4
  <span class="o">[</span>11] .plt              PROGBITS        0804833c 00033c 000090 04  AX  0   0  4
  <span class="o">[</span>12] .text             PROGBITS        080483cc 0003cc 0001f8 00  AX  0   0  4
  <span class="o">[</span>13] .fini             PROGBITS        080485c4 0005c4 00001b 00  AX  0   0  4
  <span class="o">[</span>14] .rodata           PROGBITS        080485e0 0005e0 00009f 00   A  0   0 32
  <span class="o">[</span>15] .eh_frame         PROGBITS        08048680 000680 000004 00   A  0   0  4
  <span class="o">[</span>16] .data             PROGBITS        08049684 000684 00000c 00  WA  0   0  4
  <span class="o">[</span>17] .dynamic          DYNAMIC         08049690 000690 0000c8 08  WA  5   0  4
  <span class="o">[</span>18] .ctors            PROGBITS        08049758 000758 000008 00  WA  0   0  4
  <span class="o">[</span>19] .dtors            PROGBITS        08049760 000760 000008 00  WA  0   0  4
  <span class="o">[</span>20] .jcr              PROGBITS        08049768 000768 000004 00  WA  0   0  4
  <span class="o">[</span>21] .got              PROGBITS        0804976c 00076c 000030 04  WA  0   0  4
  <span class="o">[</span>22] .bss              NOBITS          0804979c 00079c 000018 00  WA  0   0  4
  <span class="o">[</span>23] .comment          PROGBITS        00000000 00079c 000132 00      0   0  1
  <span class="o">[</span>24] .debug_aranges    PROGBITS        00000000 0008d0 000098 00      0   0  8
  <span class="o">[</span>25] .debug_pubnames   PROGBITS        00000000 000968 000040 00      0   0  1
  <span class="o">[</span>26] .debug_info       PROGBITS        00000000 0009a8 001cc6 00      0   0  1
  <span class="o">[</span>27] .debug_abbrev     PROGBITS        00000000 00266e 0002cc 00      0   0  1
  <span class="o">[</span>28] .debug_line       PROGBITS        00000000 00293a 0003dc 00      0   0  1
  <span class="o">[</span>29] .debug_frame      PROGBITS        00000000 002d18 000048 00      0   0  4
  <span class="o">[</span>30] .debug_str        PROGBITS        00000000 002d60 000bcd 01  MS  0   0  1
  <span class="o">[</span>31] .shstrtab         STRTAB          00000000 00392d 00012b 00      0   0  1
  <span class="o">[</span>32] .symtab           SYMTAB          00000000 003fa8 000740 10     33  56  4
  <span class="o">[</span>33] .strtab           STRTAB          00000000 0046e8 000467 00      0   0  1
</code></pre></div> <p>对 一个ELF可执行程序而言，一个基本的段是标记p_type为PT_INTERP的段，它表明了运行此程序所需要的程序解释器（/lib/ld- linux.so.2），实际上也就是动态连接器（dynamiclinker）。最重要的段是标记p_type为PT_LOAD的段，它表明了为运行程 序而需要加载到内存的数据。查看上面实际输入，可以看见有两个可LOAD段，第一个为只读可执行（FLg为RE）,第二个为可读可写（Flg为RW）。段 1包含了文本节.text，注意到ELF文件头部中程序进入点的值为0x80483cc，正好是指向节.text在内存中的地址。段二包含了数据 节.data，此数据节中数据是可读可写的，相对的只读数据节.rodata包含在段1中。ELF格式可以比COFF格式包含更多的调试信息，如上面所列 出的形式为.debug_xxx的节。在I386平台LINUX系统下，用命令file查看一个ELF可执行程序的可能输出是：a.out: ELF 32-bit LSB executable, Intel 80386, version 1(SYSV), for GNU/Linux 2.2.5, dynamically linked (uses shared libs), notstripped。</p> <p>ELF文件中包含了动态连接器的全路径，内核定位”正确”的动态连接器在内存中的地址是”正确”运行可执行文件的保证，参考资料 13讨论了如何通过查找动态连接器在内存中的地址以达到颠覆（Subversiver）动态连接机制的方法。</p> <p>最 后我们讨论ELF文件的动态连接机制。每一个外部定义的符号在全局偏移表(Global Offset Table GOT)中有相应的条目,如果符号是函数则在过程连接表(Procedure Linkage TablePLT)中也有相应的条目，且一个PLT条目对应一个GOT条目。对外部定义函数解析可能是整个ELF文件规范中最复杂的，下面是函数符号解析 过程的一个描述。</p> <p>1：代码中调用外部函数func,语句形式为call 0xaabbccdd,地址0xaabbccdd实际上就是符号func在PLT表中对应的条目地址（假设地址为标号.PLT2）。</p> <p>2：PLT表的形式如下</p> <div class="highlighter-rouge"><pre class="highlight"><code>.PLT0: pushl   4<span class="o">(</span>%ebx<span class="o">)</span>    /<span class="k">*</span> GOT表的地址保存在寄存器ebx中 <span class="k">*</span>/
       jmp     <span class="k">*</span>8<span class="o">(</span>%ebx<span class="o">)</span>
       nop; nop
       nop; nop
.PLT1: jmp     <span class="k">*</span>name1@GOT<span class="o">(</span>%ebx<span class="o">)</span>
       pushl   <span class="nv">$offset</span>
       jmp     .PLT0@PC
.PLT2: jmp     <span class="k">*</span>func@GOT<span class="o">(</span>%ebx<span class="o">)</span>
       pushl   <span class="nv">$offset</span>
       jmp     .PLT0@PC
</code></pre></div> <p>3：查看标号.PLT2的语句,实际上是跳转到符号func在GOT表中对应的条目。</p> <p>4：在符号没有重定位前，GOT表中此符号对应的地址为标号.PLT2的下一条语句，即是pushl $offset，其中$offset是符号func的重定位偏移量。注意到这是一个二次跳转。</p> <p>5：在符号func的重定位偏移量压栈后,控制跳到PLT表的第一条目，把GOT[1]的内容压栈，并跳转到GOT[2]对应的地址。</p> <p>6：GOT[2]对应的实际上是动态符号解析函数的代码，在对符号func的地址解析后，会把func在内存中的地址设置到GOT表中此符号对应的条目中。</p> <p>7：当第二次调用此符号时，GOT表中对应的条目已经包含了此符号的地址，就可直接调用而不需要利用PLT表进行跳转。</p> <p>动态连接是比较复杂的，但为了获得灵活性的代价通常就是复杂性。其最终目的是把GOT表中条目的值修改为符号的真实地址，这也可解释节.got包含在可读可写段中。</p> <p>动 态连接是一个非常重要的进步，这意味着库文件可以被升级、移动到其他目录等等而不需要重新编译程序（当然，这不意味库可以任意修改，如函数入参的个数、数 据类型应保持兼容性）。从很大程度上说，动态连接机制是ELF格式代替a.out格式的决定性原因。如果说面对对象的编程本质是面对接口 （interface）的编程，那么动态连接机制则是这种思想的地一个非常典型的应用，具体的讲，动态连接机制与设计模式中的桥接（BRIDGE）方法比 较类似，而它的LAZY特性则与代理（PROXY）方法非常相似。动态连接操作的细节描述请参阅参考资料 8，9，10，11。通过阅读命令readelf、objdump 的源代码以及参考资料14中所提及的相关软件源代码，可以对ELF文件的格式有更彻底的了解。</p> <p>总结 不同时期的可执行文件格式深刻的反映了技术进步的过程，技术进 步通常是针对解决存在的问题和适应新的环境。早期的UNIX系统使用a.out格式，随着操作系统和硬件系统的进步，a.out格式的局限性越来越明显。 新的可执行文件格式COFF在UNIX System VR3中出现，COFF格式相对a.out格式最大变化是多了一个节头表（section headtable），能够在包含基础的文本段、数据段、BSS段之外包含更多的段，但是COFF对动态连接和C++程序的支持仍然比较困难。为了解决上 述问题，UNIX系统实验室(UNIX SYSTEM Laboratories USL)开发出ELF文件格式，它被作为应用程序二进制接口（Application binary InterfaceABI）的一部分，其目的是替代传统的a.out格式。例如，ELF文件格式中引入初始化段.init和结束段.fini（分别对应构 造函数和析构函数）则主要是为了支持C++程序。1994年6月ELF格式出现在LINUX系统上，现在ELF格式作为UNIX/LINUX最主要的可执 行文件格式。当然我们完全有理由相信，在将来还会有新的可执行文件格式出现。</p> <p>上 述三种可执行文件格式都很好的体现了设计思想中分层的概念，由一个总的头部刻画了文件的基本要素，再由若干子头部/条目刻画了文件的若干细节。比较一下可 执行文件格式和以太数据包中以太头、IP头、TCP头的设计，我想我们能很好的感受分层这一重要的设计思想。参考资料 21从全局的角度讨论了各种文件的格式，并提出一个比较夸张的结论：Everything Is Byte!</p> <p>最后的题外话：大多数资料中对a.out格式的评价较低，常见的词语有黑暗年代（darkages）、丑陋（ugly）等等，当然，从现代的观点来看，的确是比较简单，但是如果没有曾经的简单何来今天的精巧？正如我们今天可以评价石器时代的技术是ugly,那么将来的人们也可以嘲讽今天的技术是非常ugly。我想我们也许应该用更平和的心态来对曾经的技术有一个公正的评价。</p> </article> <div class="post-share"> <div class="container"> <a href="https://twitter.com/share?url=http://amazingw.github.com/2016/03/17/linux-file-system.html&text=Linux文件格式详解" target="_blank" class="post-share-icon twitter"></a> <a href="https://www.evernote.com/clip.action?url=http://amazingw.github.com/2016/03/17/linux-file-system.html&title=Linux文件格式详解" target="_blank" class="post-share-icon evernote"></a> <a href="http://service.weibo.com/share/share.php?url=http://amazingw.github.com/2016/03/17/linux-file-system.html&title=Linux文件格式详解" target="_blank" class="post-share-icon weibo"></a> </div> </div> <div class="comment container"> <div id="disqus_thread"> <a href=""></a> </div> </div> <div class="footer"> <div class="container"> <p class="footer-entry">All content is licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA</a></p> <p class="footer-entry">Buit with <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> and <a href="https://github.com/P233/3-Jekyll" target="_blank">3-Jekyll theme</a> • Hosted on <a href="https://pages.github.com/" target="_blank">Github</a></p> </div> </div> </main> <button id="menu"> <span id="menu-icons"></span> </button> <script src="/assets/js/jquery-2.1.3.min.js"></script> <script src="/assets/js/jquery.pjax.js"></script> <script src="/assets/js/nprogress.js"></script> <script src="/assets/js/main.js"></script> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-75184518-1', 'auto'); ga('send', 'pageview'); </script> </body> </html>
