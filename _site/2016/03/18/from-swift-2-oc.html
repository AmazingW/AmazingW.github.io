<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" /> <!--[if lte IE 9]><meta http-equiv="refresh" content="0;url=/ie.html"><![endif]--> <meta name="author" content=""> <meta name="keywords" content="Objective-C,swift"> <title>从Objective-C到Swift</title> <meta name="description" content="这篇文章是自己学习Swift的笔记与深化。希望这篇文章能够帮助已经有Objective-C经验的开发者更快地学习Swift。同时也品味到Swift的精妙之处。"> <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,400italic,600|Droid+Sans+Mono' rel='stylesheet' type='text/css'> <link rel="shortcut icon" href="/assets/img/favicon.jpg" /> <link rel="stylesheet" href="/css/main.css"> <link rel="canonical" href="http://amazingw.github.com/2016/03/18/from-swift-2-oc.html"> <link rel="alternate" type="application/rss+xml" title="AW的个人博客" href="http://amazingw.github.com/pages/feed.xml" /> <script src="/assets/js/prefixfree.js"></script> </head> <body> <aside id="sidebar"> <div id="sidebar-left"> <a id="sidebar-avatar" href="/"> <img id="sidebar-avatar-img" alt="" src="/assets/icon/favicon.ico"/> </a> <div id="sidebar-social"> <a href="/pages/feed.xml" class="sidebar-social-icon feed"></a> <a href="mailto:wqf_525@live.cn" class="sidebar-social-icon email"></a> <a href="https://twitter.com/amazingw" class="sidebar-social-icon twitter" target="_blank"></a> <a href="https://github.com/amazingw" class="sidebar-social-icon github" target="_blank"></a> </div> <ul id="sidebar-tags"> <li class="sidebar-tag active" data-filter="all">全部文章</li> <li class="sidebar-tag" data-filter="服务端开发">服务端开发</li> <li class="sidebar-tag" data-filter="工具">工具</li> <li class="sidebar-tag" data-filter="资源">资源</li> <li class="sidebar-tag" data-filter="生活">生活</li> <li class="sidebar-tag" data-filter="客户端开发">客户端开发</li> <li class="sidebar-tag" data-filter="读书">读书</li> </ul> </div> <div id="sidebar-right"> <div id="search-box"> <input id="search-input" type="text" placeholder="Search" /> </div> <nav id="toc"> <a class="toc-link" data-tags="客户端开发" href="/2016/03/18/tableview-controls.html"> 类型化却不失灵活的 Table View Controller </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/18/swfit-server.html"> 服务端 Swift </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/18/from-swift-2-oc.html"> 从Objective-C到Swift </a> <a class="toc-link" data-tags="读书" href="/2016/03/18/book-list-of-2016.html"> 2016阅读书单 </a> <a class="toc-link" data-tags="工具" href="/2016/03/17/win7-service.html"> win7服务 </a> <a class="toc-link" data-tags="工具" href="/2016/03/17/issues-when-using-github.html"> github遇到问题及解决 </a> <a class="toc-link" data-tags="工具" href="/2016/03/17/error-of-cocopods.html"> cocopods 出现更新错误 </a> <a class="toc-link" data-tags="服务端开发" href="/2016/03/17/sql-use-of-explain.html"> mysql中explain用法详解 </a> <a class="toc-link" data-tags="服务端开发" href="/2016/03/17/sql-design.html"> 优化之查询语句优化 </a> <a class="toc-link" data-tags="服务端开发" href="/2016/03/17/server-design.html"> coc服务器设计图 </a> <a class="toc-link" data-tags="服务端开发" href="/2016/03/17/nodejs-deamon-fork.html"> nodejs守护进程的启动方法 </a> <a class="toc-link" data-tags="服务端开发" href="/2016/03/17/linux-file-system.html"> Linux文件格式详解 </a> <a class="toc-link" data-tags="服务端开发" href="/2016/03/17/knowledge-of-game-developper.html"> 游戏开发须知 </a> <a class="toc-link" data-tags="服务端开发" href="/2016/03/17/game-developper-code-desing.html"> 游戏设计规范要求 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/xcode-quickbutton.html"> xcode 快捷键 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/using-of-UIActivityIndicatorView.html"> UIActivityIndicatorView 的使用 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/use-of-vfl.html"> Autolayout中的Visual format language </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/use-of-rac.html"> IOS响应式编程框架ReactiveCocoa(RAC)使用示例 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/use-of-const.html"> C++ const 修饰方法注意事项 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/use-of-bundle.html"> 生成Bundle包-引入bundle-使用bundle </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/use-of-attribute-string.html"> NSAttributedString 常用方法 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/tabbar-zoom.html"> iOS，由于图片原因导致tabbar图片点击发生zoom的现象 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/symbol-not-found-for-architecture-armv7.html"> symbol(s) not found for architecture armv7 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/socket-develop-knowledge.html"> Socket网络通信框架 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/scrollview-experience.html"> UIScrollView 实践经验 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/runtime-main-point.html"> Objective C运行时（runtime）技术的几个要点总结 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/pop-experiences.html"> Pop上手体验 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/output-format.html"> NSLog 输出格式 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-useWifi.html"> iOS私有API之wifi扫描和wifi连接 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-useProtoBuffer.html"> iOS 从0使用protobuffer </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-use-NSInvocation.html"> iOS NSInvocation用法 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-use-ICONFONT.html"> 在iOS中使用icon font </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-use-GCDAsyncSocket.html"> 使用GCD AsyncSocket </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-static-librays.html"> OC静态库编辑问题 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-self-define-take-photo.html"> iOS 自定义拍照界面 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-pause-CALayer-Annimation.html"> iOS 如何暂停和恢复CALayer上的动画 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-multi-thread.html"> iOS多线程 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-Photo-memory.html"> iOS图片与内存 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-NSPredicate.html"> iOS 谓词查询NSPredicate </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-Image-Dealing.html"> iOS图片加水印或文字 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-Image-Crop-Graphics.html"> 图片裁剪 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-GCD-Thread.html"> OC线程类 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-Extension.html"> iOS开发者常用的10个Xcode插件 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-BlueTooth_develop.html"> iOS蓝牙4.0开发例子 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-Base-Knowledge.html"> iOS 开发的基本知识 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-Animations.html"> iOS 常用动画 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-Alpha-hidden-opaque.html"> iOS alpha hidden opaque </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/iOS-ActionSheet-problem.html"> UIActionSheet问题 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/hit-test-Event.html"> hitTest:withEvent:流程 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/forever-background-ios.html"> 无限后台测试代码 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/crashlog-from-dump.html"> 如何手动解析CrashLog </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/code-style-gnuc.html"> GNUC编码规范 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/c++-extern-detail.html"> C/C++中extern关键字详解 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/UITextInput-proto.html"> UITextInput协议参考 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/UITableViewCell-AutoHeight.html"> 动态计算UITableViewCell高度详解 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/RunTime-Swizzle.html"> Runtime替换方法 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/OtherLinkerFlags-iOS-XCode.html"> 关于Xcode的Other Linker Flags </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/Objc-API-Thread.html"> Objc的底层并发API </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/OC-Singleton.html"> oc 设计模式总结 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/LLVM-record.html"> LLVM操作记录 </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/Facebook-Annimation2.html"> Facebook开源动画框架 Pop体验（二） </a> <a class="toc-link" data-tags="客户端开发" href="/2016/03/17/Facebook-Annimation1.html"> Facebook开源动画框架 Pop体验（一） </a> <a class="toc-link" data-tags="资源" href="/2015/10/04/general-vim-resources.html"> Vim 常用资源 </a> <a class="toc-link" data-tags="服务端开发" href="/2015/09/07/sort-algorithms.html"> 七种常见经典排序算法总结（C++实现） </a> <a class="toc-link" data-tags="资源" href="/2015/02/13/general-seo-resources.html"> SEO 常用资源 </a> <a class="toc-link" data-tags="工具" href="/2015/01/10/use-dropzone-and-qiniu-to-store-blog-images.html"> 使用Dropzone和七牛云存储来优化博客图床 </a> <a class="toc-link" data-tags="服务端开发" href="/2015/01/08/conflict-between-camel-and-snake-in-laravel.html"> Laravel 关联模型由于名称一致性导致的问题 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/12/06/ioc-and-facade-in-laravel.html"> Laravel 核心：控制反转（Inversion of Control）和门面模式（Facade） </a> <a class="toc-link" data-tags="服务端开发" href="/2014/09/26/use-old-version-of-brew-php.html"> 回退Mac上用Brew安装的PHP版本 </a> <a class="toc-link" data-tags="资源" href="/2014/08/03/general-mac-resources.html"> Mac 常用资源 </a> <a class="toc-link" data-tags="资源" href="/2014/05/11/general-mysql-resources.html"> MySQL常用资源 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/05/04/set-environment-variables-of-server-for-php.html"> 为PHP设置服务器(Apache/Nginx)环境变量 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/04/27/magic-methods-and-magic-constants-in-php.html"> PHP中的魔术方法和魔术常量简介和使用 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/04/23/roc-curve.html"> ROC曲线 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/04/19/design-patterns-of-php.html"> 设计模式详解及PHP实现 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/04/16/insert-large-number-of-data-in-mysql.html"> MySQL大量数据插入各种方法性能分析与比较 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/04/11/redis-queue-in-laravel.html"> Laravel中使用Redis作为队列系统的工作流程 </a> <a class="toc-link" data-tags="工具" href="/2014/04/10/install-vagrant-in-mac.html"> 在Mac下安装使用Vagrant </a> <a class="toc-link" data-tags="工具" href="/2014/04/10/install-docker-in-mac.html"> 在Mac下安装使用Docker </a> <a class="toc-link" data-tags="服务端开发" href="/2014/03/22/managing-your-larrvel-queue-by-supervisor.html"> 使用Supervisor来管理你的Laravel队列 </a> <a class="toc-link" data-tags="工具" href="/2014/03/20/php-debug-with-xdebug.html"> 用Xdebug和Sublime调试PHP代码 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/03/20/use-other-libraries-in-laravel.html"> 在Laravel中使用自己的类库三种方式 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/03/10/grunt-bower-and-laravel.html"> 用Laravel+Grunt+Bower管理你的应用 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/02/15/apache-and-nginx.html"> 从运行原理及使用场景看Apache和Nginx </a> <a class="toc-link" data-tags="工具" href="/2014/02/12/how-to-deploy-a-blog-on-github-by-jekyll.html"> 在Github上搭建Jekyll博客和创建主题 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/01/30/understanding-the-github-workflow.html"> 了解GitHub工作流【译】 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/01/25/how-to-use-php-socket.html"> PHP Socket的使用 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/01/24/apache-log-format.html"> Apache 日志文件格式及简单处理 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/01/17/python-script-of-sae-log-download.html"> Python脚本--下载合并SAE日志 </a> <a class="toc-link" data-tags="服务端开发" href="/2014/01/16/php-namespace-and-autoload.html"> PHP命名空间及自动加载 </a> <a class="toc-link" data-tags="资源" href="/2014/01/15/general-svn-resources.html"> SVN 常用资源 </a> <a class="toc-link" data-tags="资源" href="/2014/01/15/general-shell-resources.html"> Shell 常用资源 </a> <a class="toc-link" data-tags="资源" href="/2014/01/15/general-python-resources.html"> Python 常用资源 </a> <a class="toc-link" data-tags="资源" href="/2014/01/15/general-php-resources.html"> PHP 常用资源 </a> <a class="toc-link" data-tags="资源" href="/2014/01/15/general-jquery-resources.html"> jQuery 常用资源 </a> <a class="toc-link" data-tags="资源" href="/2014/01/15/general-javascript-resources.html"> JavaScript 常用资源 </a> <a class="toc-link" data-tags="资源" href="/2014/01/15/general-html-resources.html"> HTML 常用资源 </a> <a class="toc-link" data-tags="资源" href="/2014/01/15/general-git-resources.html"> Git 常用资源 </a> <a class="toc-link" data-tags="工具" href="/2013/12/11/lamp-in-mac.html"> Mac下用brew搭建PHP(LNMP/LAMP)开发环境 </a> <a class="toc-link" data-tags="工具" href="/2013/12/11/deploy-pptp-vpn-in-ubuntu.html"> 在ubuntu下搭建pptp vpn服务器 </a> <a class="toc-link" data-tags="工具" href="/2013/12/08/linux-command-continue.html"> Linux下多个命令连续执行方法 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/12/08/implemention-of-breadcrumbs-by-css3.html"> 基于CSS3实现尖角面包屑 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/10/01/deploy-ceilometer-of-openstack.html"> 部署Ceilometer到已有环境中 </a> <a class="toc-link" data-tags="工具" href="/2013/08/28/change-bootstrap-to-3.html"> 更新前端框架到Bootstrap3 </a> <a class="toc-link" data-tags="工具" href="/2013/08/06/tools-of-reading.html"> 我与工具--阅读和知识管理 </a> <a class="toc-link" data-tags="生活" href="/2013/08/01/program-and-life.html"> 关于效率、程序与生活的一些思考 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/06/12/hacking-in-openstack-ceilometer-collector.html"> OpenStack Ceilometer Collector代码解读 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/06/12/hacking-in-openstack-ceilometer-api.html"> OpenStack Ceilometer数据存储与API源码解析 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/06/11/pipeline-of-openstack-ceilometer.html"> OpenStack Ceilometer中的Pipeline机制 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/06/11/hacking-in-openstack-ceilometer-compute-agent.html"> OpenStack Ceilometer Compute Agent源码解读 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/06/09/learn-python-stevedore-module-in-detail.html"> 学习Python动态扩展包stevedore </a> <a class="toc-link" data-tags="服务端开发" href="/2013/06/09/learn-python-abc-module.html"> 学习Python的ABC模块 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/06/07/learn-python-setuptools-in-detail.html"> Python包管理工具setuptools详解 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/05/27/openstack-horizon-locale.html"> OpenStack Horizon 中文本地化 </a> <a class="toc-link" data-tags="工具" href="/2013/05/23/install-mysql-and-mongo-web-admin.html"> 安装MySQL和MongoDB的WEB管理界面 </a> <a class="toc-link" data-tags="工具" href="/2013/05/22/change-to-zsh.html"> 从Bash切换到Zsh </a> <a class="toc-link" data-tags="工具" href="/2013/05/20/set-proxy-for-git-or-apt.html"> 给Git或者APT设置goagent代理 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/05/19/what-is-wsgi.html"> WSGI学习 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/05/16/deploy-openstack-grizzly-in-virtual-machine.html"> 在虚拟机单机部署OpenStack Grizzly </a> <a class="toc-link" data-tags="服务端开发" href="/2013/05/15/learn-how-to-use-distutils.html"> 学习使用python打包工具distutils </a> <a class="toc-link" data-tags="服务端开发" href="/2013/05/15/different-between-python-package-tools.html"> python包工具之间的关系 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/05/15/create-ubuntu-image-for-openstack.html"> 给OpenStack创建Ubuntu镜像 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/05/13/openstack-grizzly-multihost-deployment-doc.html"> OpenStack Grizzly Multihost部署文档 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/05/06/why-use-pip-over-easy-install.html"> 为什么使用pip而不是easy_install </a> <a class="toc-link" data-tags="服务端开发" href="/2013/05/06/the-viewpoint-metatag.html"> HTML中meta标签viewpoint的作用 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/05/06/interactive-coding-ipython.html"> 交互式编程-IPython </a> <a class="toc-link" data-tags="服务端开发" href="/2013/05/03/php-cache-of-a-page.html"> 页面提速之——数据缓存 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/05/03/create-windows-7-image-for-openstack.html"> 给OpenStack创建Win7镜像 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/05/01/terminal-command-of-ceilometer.html"> Ceilometer的命令行使用 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/05/01/deploy-a-ceilometer-horizon-project.html"> 部署一个ceilometer-horizon项目 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/04/26/create-windows-xp-image-for-openstack.html"> 给OpenStack创建Windows XP镜像 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/04/25/some-concept-about-enterprise-storage.html"> 几种企业的存储系统 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/04/25/conceptual-logical-physical.html"> 概念模型、逻辑模型、物理模型的区别 </a> <a class="toc-link" data-tags="工具" href="/2013/04/23/deploy-jeklly-blog.html"> 在GitHub上搭建自己的Jekyll博客--了解环境 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/04/23/opensource-licenses.html"> 五中常见的开源协议整理(BSD,Apache,GPL,LGPL,MIT) </a> <a class="toc-link" data-tags="资源" href="/2013/04/23/general-bootstrap-resources.html"> Bootstrap常用资源 </a> <a class="toc-link" data-tags="工具" href="/2013/04/22/wordpress-to-jekyll.html"> 博客迁移完成 </a> <a class="toc-link" data-tags="工具" href="/2013/04/22/ignore-password-in-git-push.html"> 让git push命令不再需要密码 </a> <a class="toc-link" data-tags="工具" href="/2013/04/22/highlight-of-jekyll.html"> Jekyll的中的代码高亮 </a> <a class="toc-link" data-tags="工具" href="/2013/04/22/add-svn-ignore-file.html"> 给SVN控制的项目添加忽略文件/文件夹 </a> <a class="toc-link" data-tags="工具" href="/2013/04/21/add-snippet.html"> 给sublime增加snippet </a> <a class="toc-link" data-tags="服务端开发" href="/2013/03/27/glossary-of-ceilometer.html"> OpenStack监控项目Ceilometer的一些术语 </a> <a class="toc-link" data-tags="工具" href="/2013/03/25/tools-of-sever-deployment.html"> 服务器自动化部署及运维常见工具 </a> <a class="toc-link" data-tags="工具" href="/2013/03/25/open-tcp-port-of-libvirt.html"> Linux下开启Libvirtd的tcp监控 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/03/21/vnc-vs-rdp.html"> VNC和远程桌面的区别 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/03/21/introduction-of-ceilometer.html"> OpenStack Ceilometer项目简介 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/03/20/different-bewteen-kvm-xen-qemu.html"> 虚拟化与云计算中KVM,Xen,Qemu的区别和联系 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/03/20/debug-and-modify-openstack-horizon.html"> 调试和修改OpenStack中的Horizon部分 </a> <a class="toc-link" data-tags="工具" href="/2013/02/25/quick-open-in-windows.html"> win7快速打开应用程序或文件 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/02/24/javascript-variable-domain.html"> JavaScript变量作用域 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/01/30/introduction-of-kanyun-worker.html"> kanyun worker原理 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/01/30/introduction-kanyun-server.html"> kanyun server服务 </a> <a class="toc-link" data-tags="服务端开发" href="/2013/01/30/deploy-kanyun.html"> 在OpenStack中部署kanyun </a> <a class="toc-link" data-tags="服务端开发" href="/2013/01/30/command-of-kanyun.html"> kanyun的api-client命令 </a> <a class="toc-link" data-tags="工具" href="/2013/01/16/create-remote-resp.html"> git创建远程库 </a> <a class="toc-link" data-tags="工具" href="/2013/01/09/remote-access-of-mysql.html"> MySQL远程访问 </a> <a class="toc-link" data-tags="服务端开发" href="/2012/12/31/python-development-of-sae.html"> sae下的python开发部署和一个简单例子 </a> <a class="toc-link" data-tags="工具" href="/2012/12/30/share-windows-and-linux.html"> Windows和Linux切换最终解决方案 </a> <a class="toc-link" data-tags="服务端开发" href="/2012/11/08/openstack-nova-internal.html"> OpenStack Nova内部机制【译】 </a> <a class="toc-link" data-tags="服务端开发" href="/2012/09/27/php-variable-variables.html"> PHP可变变量 </a> <a class="toc-link" data-tags="服务端开发" href="/2012/09/27/open-widown-in-javascript.html"> JS中防止浏览器屏蔽window.open </a> <a class="toc-link" data-tags="服务端开发" href="/2012/09/19/php-session-security.html"> PHP操作Session的原理及提升安全性时的一个问题 </a> </nav> </div> </aside> <main id="main"> <article class="post container"> <div class="post-meta"> <span class="post-meta-span date">2016 March 18</span> <span class="post-meta-span tag">Objective-C, swift</span> </div> <h1 class="post-title">从Objective-C到Swift</h1> <p>这篇文章是自己学习Swift的笔记与深化。希望这篇文章能够帮助已经有Objective-C经验的开发者更快地学习Swift。同时也品味到Swift的精妙之处。</p> <p>结论放在开头:我认为Swift比Objective-C更优雅,更安全同时也更现代,更性感。</p> <p>文章组织脉络：</p> <ul> <li> <p>从Objective-C到Swift的语法差异。我们熟悉的Objective-C特性在Swift中如何展现。</p> </li> <li> <p>从Objective-C到Swift的进步改进。研究对比Swift在安全性,易用性上的提升,给我们带来的新编程范式。</p> </li> </ul> <p>目录：</p> <p>1.属性(property)和实例变量(instance variable)</p> <p>2.控制流</p> <p>3.函数</p> <p>4.类与初始化(Initializers)</p> <p>5.枚举与结构体</p> <p>6.协议(Protocols)</p> <p>7.Swift与Cocoa</p> <p>8.总结</p> <p>1.属性(property)和实例变量(instance variable)</p> <p>Objective-C property in Swift world</p> <p>在Cocoa世界开发的过程中,我们最常打交道的是property.</p> <p>典型的声明为:</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="k">@property</span> <span class="p">(</span><span class="n">strong</span><span class="p">,</span><span class="n">nonatomic</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">string</span><span class="p">;</span>
</code></pre></div> <p>而在Swift当中,摆脱了C的包袱后,变得更为精炼,我们只需直接在类中声明即可</p> <div class="highlighter-rouge"><pre class="highlight"><code>class Shape {
    var name = "shape"
}
</code></pre></div> <p>注意到这里,我们不再需要@property指令,而在Objective-C中,我们可以指定property的attribute,例如strong,weak,readonly等。</p> <p>而在Swift的世界中,我们通过其他方式来声明这些property的性质。</p> <p>需要注意的几点:</p> <ul> <li> <p>strong: 在Swift中是默认的</p> </li> <li> <p>weak: 通过weak关键词申明</p> </li> </ul> <p>1</p> <p>weak var delegate: UITextFieldDelegate?</p> <ul> <li> <p>readonly,readwrie 直接通过声明常量let,声明变量var的方式来指明</p> </li> <li> <p>copy 通过@NSCopying指令声明。</p> </li> </ul> <p>值得注意的是String,Array和Dictionary在Swift是以值类型(value type)而不是引用类型(reference type)出现,因此它们在赋值,初始化,参数传递中都是以拷贝的方式进行（简单来说,String,Array,Dictionary在Swift中是通过struct实现的）</p> <p>延伸阅读：Value and Reference Types</p> <ul> <li>nonatomic,atomic 所有的Swift properties 都是nonatomic。但是我们在线程安全上已经有许多机制,例如NSLock,GCD相关API等。个人推测原因是苹果想把这一个本来就用的很少的特性去掉,线程安全方面交给平时我们用的更多的机制去处理。</li> </ul> <p>然后值得注意的是,在Objective-C中,我们可以跨过property直接与instance variable打交道,而在Swift是不可以的。</p> <p>例如：我们可以不需要将someString声明为property,直接使用即可。即使我们将otherString声明为property,我们也可以直接用_otherString来使用property背后的实例变量。</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="k">@interface</span> <span class="nc">SomeClass</span> <span class="p">:</span> <span class="nc">NSObject</span> <span class="p">{</span>
  <span class="n">NSString</span> <span class="o">*</span><span class="n">someString</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@property</span><span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span> <span class="n">NSString</span><span class="o">*</span> <span class="n">otherString</span><span class="p">;</span>
</code></pre></div> <p>而在Swift中,我们不能直接与instance variable打交道。也就是我们声明的方式简化为简单的一种,简单来说在Swift中,我们只与property打交道。</p> <p>A Swift property does not have a corresponding instance variable, and the backing store for a property is not accessed directly</p> <p>小结</p> <ul> <li> <p>因此之前使用OC导致的像巧哥指出的开发争议就不再需要争执了,在Swift的世界里,我们只与property打交道。</p> </li> <li> <p>并且我们在OC中init和dealloc不能使用属性self.property = XXX来进行设置的情况得以解决和统一。</p> </li> </ul> <p>(不知道这一条规定,在init直接用self.property = value 的同学请自觉阅读iOS夯实：内存管理)</p> <p>个人觉得这看似小小一点变动使Swift开发变得更加安全以及在代码的风格更为统一与稳定。</p> <p>Swift property延伸：</p> <ul> <li>Stored Properties和Computed properties</li> </ul> <p>在Swift中,property被分为两类：Stored Properties和Computed properties 简单来说,就是stored properties 能够保存值,而computed properties只提供getter与setter,利用stored properties来生成自己的值。个人感觉Computed properties更像方法,而不是传统意义的属性。但是这样一个特性存在,使得我们更容易组织我们的代码。</p> <p>延伸阅读：computed property vs function</p> <ul> <li>Type Properties</li> </ul> <p>Swift提供了语言级别定义类变量的方法。</p> <p>In C and Objective-C, you define static constants and variables associated with a type as global static variables.In Swift, however, type properties are written as part of the type’s definition, within the type’s outer curly braces, and each type property is explicitly scoped to the type it supports.</p> <p>在Objective-C中,我们只能通过单例,或者static变量加类方法来自己构造类变量：</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="k">@interface</span> <span class="nc">Model</span>
<span class="k">+</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">value</span><span class="p">;</span>
<span class="k">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">setValue</span><span class="p">:(</span><span class="kt">int</span><span class="p">)</span><span class="nv">val</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Model</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
<span class="k">+</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">value</span>
<span class="p">{</span> <span class="k">@synchronized</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">value</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span>
<span class="o">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">setValue</span><span class="o">:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">val</span>
<span class="p">{</span> <span class="k">@synchronized</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span>
<span class="k">@end</span>
</code></pre></div> <div class="highlighter-rouge"><pre class="highlight"><code>// Foo.h
@interface Foo {
}

+(NSDictionary*) dictionary;

// Foo.m
+(NSDictionary*) dictionary
{
  static NSDictionary* fooDict = nil;

  static dispatch_once_t oncePredicate;

  dispatch_once(&amp;oncePredicate, ^{
        // create dict
    });

  return fooDict;
}
</code></pre></div> <p>而在Swift中我们通过清晰的语法便能定义类变量：</p> <p>通过static定义的类变量无法在子类重写,通过class定义的类变量则可在子类重写。</p> <div class="highlighter-rouge"><pre class="highlight"><code>struct SomeStructure {
    static var storedTypeProperty = "Some value."
    static var computedTypeProperty: Int {
        return 1
    }
    class var overrideableComputedTypeProperty: Int {
        return 107
    }
}
</code></pre></div> <p>同时利用类变量我们也有了更优雅的单例模式实现：</p> <div class="highlighter-rouge"><pre class="highlight"><code>class singletonClass {
    static let sharedInstance = singletonClass()
    private init() {} // 这就阻止其他对象使用这个类的默认的'()'初始化方法
}
</code></pre></div> <p>Swift单例模式探索：The Right Way to Write a Singleton</p> <ul> <li>延伸：目前Swift支持的type propertis中的Stored Properties类型不是传统意义上的类变量(class variable)，暂时不能通过class 关键词定义,通过static定义的类变量类似java中的类变量,是无法被继承的,父类与子类的类变量指向的都是同一个静态变量。</li> </ul> <p>延伸阅读： Class variables not yet supported</p> <div class="highlighter-rouge"><pre class="highlight"><code>class SomeStructure {
    class var storedTypeProperty = "Some value."
}
</code></pre></div> <p>//Swift 2.0 Error: Class stored properties not yet supported in classes</p> <p>通过编译器抛出的错误信息,相信在未来的版本中会完善Type properties。</p> <p>2.控制流</p> <p>Swift与Objective-C在控制流的语法上关键词基本是一致的,但是扩展性和安全性得到了很大的提升。</p> <p>主要有三种类型的语句</p> <ul> <li> <p>if,switch和新增的guard</p> </li> <li> <p>for,while</p> </li> <li> <p>break,continue</p> </li> </ul> <p>主要差异有：</p> <p>关于if</p> <p>语句里的条件不再需要使用()包裹了。</p> <div class="highlighter-rouge"><pre class="highlight"><code>let number = 23
if number &lt; 10 {
    print("The number is small")
}
</code></pre></div> <p>但是后面判断执行的的代码必须使用{}包裹住。</p> <p>为什么呢,在C,C++等语言中,如果后面执行的语句只有语句,我们可以写成:</p> <div class="highlighter-rouge"><pre class="highlight"><code>  int number = 23
    if (number &lt; 10)
        NSLog("The number is small")
</code></pre></div> <p>但是如果有时要在后面添加新的语句,忘记添加{},灾难就很可能发送。</p> <p>：） 像苹果公司自己就犯过这样的错误。下面这段代码就是著名的goto fail错误,导致了严重的安全性问题。</p> <div class="highlighter-rouge"><pre class="highlight"><code>  if ((err = SSLHashSHA1.update(&amp;hashCtx, &amp;signedParams)) != 0)
    goto fail;
    goto fail;  // :)注意 这不是Python的缩减
  ... other checks ...
  fail:
    ... buffer frees (cleanups) ...
    return err;
</code></pre></div> <p>最终在Swift,苹果终于在根源上消除了可能导致这种错误的可能性。</p> <p>if 后面的条件必须为Boolean表达式</p> <p>也就是不会隐式地与0进行比较,下面这种写法是错误的,因为number并不是一个boolean表达式,number != 0才是。</p> <div class="highlighter-rouge"><pre class="highlight"><code>int number = 0
if number{
}
</code></pre></div> <p>关于for</p> <p>for循环在Swift中变得更方便,更强大。</p> <p>得益于Swift新添加的范围操作符…与…&lt;</p> <p>我们能够将之前繁琐的for循环：</p> <div class="highlighter-rouge"><pre class="highlight"><code>for (int i = 1; i &lt;= 5; i++)
{
    NSLog(@"%d", i);
}
</code></pre></div> <p>改写为：</p> <div class="highlighter-rouge"><pre class="highlight"><code>for index in 1...5 {
    print(index)
}
</code></pre></div> <p>当然,熟悉Python的亲们知道Python的range函数很方便,我们还能自由选择步长。 像这样：</p> <blockquote> <blockquote> <blockquote> <p>range(1,5) #代表从1到5(不包含5)</p> </blockquote> </blockquote> </blockquote> <p>[1, 2, 3, 4]</p> <blockquote> <blockquote> <blockquote> <p>range(1,5,2) #代表从1到5，间隔2(不包含5)</p> </blockquote> </blockquote> </blockquote> <p>[1, 3]</p> <p>虽然在《The Swift Programming Language》里面没有提到类似的用法,但是在Swift中我们也有优雅的方法办到。</p><pre><code class="language-`">for index in stride(from: 1, through: 5, by: 2) {
    print(index)
}// through是包括5
</code></pre><p>然后对字典的遍历也增强了.在Objective-c的快速枚举中我们只能对字典的键进行枚举。</p> <div class="highlighter-rouge"><pre class="highlight"><code>NSString *key;
for (key in someDictionary){
     NSLog(@"Key: %@, Value %@", key, [someDictionary objectForKey: key]);
}
</code></pre></div> <p>而在Swift中,通过tuple我们可以同时枚举key与value:</p> <div class="highlighter-rouge"><pre class="highlight"><code>let dictionary = ["firstName":"Mango","lastName":"Fang"]
for (key,value) in dictionary{
    print(key+" "+value)
}
</code></pre></div> <p>关于Switch</p> <p>Swich在Swift中也得到了功能的增强与安全性的提高。</p> <p>不需要Break来终止往下一个Case执行</p> <p>也就是下面这两种写法是等价的。</p> <div class="highlighter-rouge"><pre class="highlight"><code>let character = "a"
switch character{
    case "a":
        print("A")
    break
    case "b":
        print("B")
    break
default: print("character")

let character = "a"
switch character{
    case "a":
        print("A")
    case "b":
        print("B")
default: print("character")
</code></pre></div> <p>这种改进避免了忘记写break造成的错误,自己深有体会,曾经就是因为漏写了break而花了一段时间去debug。</p> <p>如果我们想不同值统一处理,使用逗号将值隔开即可。</p> <div class="highlighter-rouge"><pre class="highlight"><code>switch some value to consider {
case value 1,value 2:
    statements
}
</code></pre></div> <p>Switch支持的类型</p> <p>在OC中,Swtich只支持int类型,char类型作为匹配。</p> <p>而在Swift中,Switch支持的类型大大的拓宽了。实际上,苹果是这么说的。</p> <p>A switch statement supports any kind of data</p> <p>这意味在开发中我们能够能够对字符串,浮点数等进行匹配了。</p> <p>之前在OC繁琐的写法就可以进行改进了:</p> <div class="highlighter-rouge"><pre class="highlight"><code>if ([cardName isEqualToString:@"Six"]) {
    [self setValue:6];
} else if ([cardName isEqualToString:@"Seven"]) {
    [self setValue:7];
} else if ([cardName isEqualToString:@"Eight"]) {
    [self setValue:8];
} else if ([cardName isEqualToString:@"Nine"]) {
    [self setValue:9];
}

switch carName{
    case "Six":
        self.vaule = 6
    case "Seven":
        self.vaule = 7
    case "Eight":
        self.vaule = 8
    case "Night":
        self.vaule = 9
}
</code></pre></div> <p>3.函数</p> <p>对于在OC中,方法有两种类型,类方法与实例方法。方法的组成由方法名,参数,返回值组成。</p> <p>在Swift中函数的定义基本与OC一样。</p> <p>主要区别为：</p> <div class="highlighter-rouge"><pre class="highlight"><code>通过func关键词定义函数

返回值在-&gt;关键词后标注
</code></pre></div> <p>各举一个类方法与实例方法例子。</p> <div class="highlighter-rouge"><pre class="highlight"><code>+ (UIColor*)blackColor
- (void)addSubview:(UIView *)view
</code></pre></div> <p>对应的swift版本</p> <div class="highlighter-rouge"><pre class="highlight"><code>    class func blackColor() -&gt; UIColor //类方法, 通过 class func 关键词声明
    func addSubview(view: UIView) //实例方法
</code></pre></div> <p>改进：</p> <p>在Swift中,函数的最重要的改进就是函数作为一等公民(first-class),和对象一样可以作为参数进行传递,可以作为返回值,函数式编程也成为了Swift支持的编程范式。</p> <p>In computer science, a programming language is said to have first-class functions if it treats functions as first-class citizens. Specifically, this means the language supports passing functions as arguments to other functions, returning them as the values from other functions, and assigning them to variables or storing them in data structures</p> <p>让我们初略感受一下函数式编程的魅力:</p> <p>举一个例子,我们要筛选出一个数组里大于4的数字。</p> <p>在OC中我们可能会用快速枚举来进行筛选。</p> <div class="highlighter-rouge"><pre class="highlight"><code>   NSArray *oldArray = @[@1,@2,@3,@4,@5,@6,@7,@8,@9,@10];
    NSMutableArray *newArray;
    for (NSNumber* number in oldArray) {
        if ([number compare:@4] == NSOrderedDescending ) {
            [newArray addObject:number];
        }
    }
</code></pre></div> <p>而在Swift中,我们用两行代码解决这个问题：</p> <div class="highlighter-rouge"><pre class="highlight"><code>let oldArray = [1,2,3,4,5,6,7,8,9,10]
let newArray = oldArray.filter({$0 &gt; 4})
</code></pre></div> <p>进一步了解Swift的函数式编程可以通过这篇优秀的博客Functional Reactive Programming in Swift</p> <div class="highlighter-rouge"><pre class="highlight"><code>个人觉得另外一个很棒的改进是：Default parameter values
</code></pre></div> <p>在我们的项目中,经常会不断进行功能的增添。为了新增特性,许多方法在开发的过程中不断变动。举一个例子：我们开始有一个tableViewCell,它的设置方法一开始简单地需要一个Model参数：</p> <div class="highlighter-rouge"><pre class="highlight"><code>func configureCellWithModel(Model: model)
</code></pre></div> <p>不久之后,我们想对部分Cell增添一个设置背景颜色的功能。方法需要再接收多一个参数：</p> <div class="highlighter-rouge"><pre class="highlight"><code>func configureCellWithModel(Model: model,color:UIColor)
</code></pre></div> <p>这个时候方法改变,所以涉及到这些方法的地方都需要修改。给我们造成的困扰</p> <p>一是：需要做许多重复修改的工作。</p> <p>二是：无法做得很好的扩展和定制,有些地方的cell需要设置颜色,有些不需要。但是在OC里,我们只能对所有的cell都赋值。你可能觉得我们可以写两个方法,一个接收颜色参数,一个不接受。但是我们知道这不是一个很好的解决方法,会造成冗余的代码,维护起来也不方便。</p> <p>而在Swift中,default parameter values的引入让我们能够这样修改我们的代码：</p> <div class="highlighter-rouge"><pre class="highlight"><code>func configureCellWithModel(Model: model,color:UIColor = UIColor.whiteColor())
</code></pre></div> <p>这样的改进能让我们写出的代码更具向后兼容性,减少了我们的重复工作量,减少了犯错误的可能性。</p> <p>4.类与初始化（Initializers）</p> <p>文件结构与访问控制</p> <p>在swift中,一个类不再分为interface（.h）与implementation(.m)两个文件实现,直接在一个.swift文件里进行处理。好处就是我们只需管理一份文件,以往两头奔波修改的情况就得到解放了,也减少了头文件与实现文件不同步导致的错误。</p> <p>这时我们会想到,那么我们如何来定义私有方法与属性呢,在OC中我们通过在class extension中定义私有属性,在.m文件定义私有方法。</p> <p>而在Swift中,我们通过Access Control来进行控制。</p> <p>properties, types, functions等能够进行版本控制的统称为实体。</p> <ul> <li> <p>Public：可以访问自己模块或应用中源文件里的任何实体，别人也可以访问引入该模块中源文件里的所有实体。通常情况下，某个接口或Framework是可以被任何人使用时，你可以将其设置为public级别。</p> </li> <li> <p>Internal：可以访问自己模块或应用中源文件里的任何实体，但是别人不能访问该模块中源文件里的实体。通常情况下，某个接口或Framework作为内部结构使用时，你可以将其设置为internal级别。</p> </li> <li> <p>Private：只能在当前源文件中使用的实体，称为私有实体。使用private级别，可以用作隐藏某些功能的实现细节</p> </li> </ul> <p>一个小技巧,如果我们有一系列的私有方法,我们可以把它们组织起来,放进一个extension里,这样就不需要每个方法都标记private,同时也便于管理组织代码：</p> <div class="highlighter-rouge"><pre class="highlight"><code>// MARK: Private
private extension ViewController {
    func privateFunction() {
    }
}
</code></pre></div> <p>创建对象与alloc和init</p> <p>关于初始化,在Swift中创建一个对象的语法很简洁：只需在类名后加一对圆括号即可。</p> <div class="highlighter-rouge"><pre class="highlight"><code>var shape = Shape()
</code></pre></div> <p>而在Swift中,initializer也与OC有所区别,Swift的初始化方法不返回数据。而在OC中我们通常返回一个self指针。</p> <p>Unlike Objective-C initializers, Swift initializers do not return a value. Their primary role is to ensure that new instances of a type are correctly initialized before they are used for the first time.</p> <p>Swift的初始化方法让我们只关注对象的初始化。之前在OC世界中为什么要self = [super init]？。这种问题得以避免。Swift帮助我们处理了alloc的过程。也让我们的代码更简洁明确。</p> <p>而在Swift中,init也有了更严格的规则。</p> <ul> <li>对于所有Stored Properties,都必须在对象被创建出来前设置好。也就是我们必须在init方法中赋好值,或是直接给属性提供一个默认值。</li> </ul> <p>如果有property可以被允许在初始出来时没有值,也就是需要在创建出来后再赋值,或是在程序运行过程都可能不会被赋值。那么这个property必须被声明为optional类型。该类型的属性会在init的时候初始化为nil.</p> <ul> <li>initializer严格分为Designated Initializer和Convenience Initializer 并且有语法定义。</li> </ul> <p>而在Objective-C中没有明确语法标记哪个初始化方式是convenience方法。关于Designated Initializer可参阅之前的:Objective-C 拾遗：designated initializer</p> <div class="highlighter-rouge"><pre class="highlight"><code>init(parameters) {
    statements
}

convenience init(parameters) {
    statements
}
</code></pre></div> <p>5.枚举与结构体</p> <ul> <li>枚举</li> </ul> <p>在Swift中,枚举是一等公民。(first-class)。能够拥有方法,computed properties等以往只有类支持的特性。</p> <p>在C中,枚举为每个成员指定一个整型值。而在Swift中,枚举更强大和灵活。我们不必给枚举成员提供一个值。如果我们想要为枚举成员提供一个值(raw value),我们可以用字符串,字符,整型或浮点数类型。</p> <div class="highlighter-rouge"><pre class="highlight"><code>enum CompassPoint {
case North
case South
case East
case West
  }
  var directionToHead = CompassPoint.West
</code></pre></div> <ul> <li>结构体</li> </ul> <p>Struct在Swift中和类有许多相同的地方,可以定义属性,方法,初始化方法,可通过extension扩展等。</p> <p>不同的地方在于struct是值类型.在传递的过程中都是通过拷贝进行。</p> <p>在这里要提到在前面第一节处提到了String,Array和Dictionary在Swift是以值类型出现的。这背后的原因就是String,Array,Dictionary在Swift中是通过Struct实现的。而之前在Objective-C它们都是通过class实现的。</p> <p>Swift中强大的Struct使得我们能够更多与值类型打交道。Swift的值类型增强了不可变性(Immutabiliity)。而不可变性提升了我们代码的稳定性,多线程并发的安全性。</p> <p>在WWDC2014《Advanced iOS Application Architecture and Patterns》中就有一节的标题是Simplify with immutability。</p> <p>延伸阅读：WWDC心得：Advanced iOS Application Architecture and Patterns</p> <p>6.协议（Protocols）</p> <p>语法:</p> <p>在Objective-C中我们这么声明Protocol:</p> <div class="highlighter-rouge"><pre class="highlight"><code><span class="k">@protocol</span> <span class="nc">SampleProtocol</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">someMethod</span><span class="p">;</span>
<span class="k">@end</span>
</code></pre></div> <p>而在Swift中：</p> <div class="highlighter-rouge"><pre class="highlight"><code>protocol SampleProtocol
{
    func someMethod()
}
</code></pre></div> <p>在Swift遵循协议:</p> <div class="highlighter-rouge"><pre class="highlight"><code>class AnotherClass: SomeSuperClass, SampleProtocol
{
    func someMethod() {}
}
</code></pre></div> <p>那么之前Objective-C的protocol中,我们可以标志optional。那在Swift中呢？</p> <p>遗憾的是,目前纯Swift的protocol还不支持optional。但根据苹果官方论坛的一位员工的回答,未来Swift是会支持的。</p> <p>Optional methods in protocols are limited to @objc protocols only because we haven’t implemented them in native protocols yet. This is something we plan to support. We’ve gotten a number of requests for abstract/pure virtual classes and methods too.</p> <p>— Joe Groff</p> <p>Source: https://devforums.apple.com/message/1051431#1051431</p> <p>protocol和delegate是紧密联系的。那么我们在Swift中如何定义Delegate呢？</p> <div class="highlighter-rouge"><pre class="highlight"><code>protocol MyDelegate : class {
}
class MyClass {
    weak var delegate : MyDelegate?
}
</code></pre></div> <p>注意到上面的protocol定义后面跟着的class。这意味着该protocol只能被class类型所遵守。</p> <p>并且只有遵守了class protocol的delegate才能定义为weak。这是因为在Swift中,除了class能够遵守协议,枚举和结构同样能够遵守协议。而枚举和结构是值类型,不存在内存管理的问题。因此只需要class类型的变量声明为weak即可。</p> <p>利用Swift的optional chaining,我们能够很方便的检查delegate是否为Nil,是否有实现某个方法:</p> <p>以前我们要在Objective-C这样检查：</p> <div class="highlighter-rouge"><pre class="highlight"><code> if (self.dataSource &amp;&amp; [self.dataSource respondsToSelector:@selector(titleForSegmentAtIndex:)]) {
        thisSegmentTitle = [self.dataSource titleForSegmentAtIndex:index];
    }
</code></pre></div> <p>在Swift中,非常的优雅简洁。</p> <div class="highlighter-rouge"><pre class="highlight"><code>if let thisSementTitle = dataSource?.titleFroSegmentAtIndex?(index){
}
</code></pre></div> <p>新特性:</p> <p>1.在Swift中,protocol变得更加强大,灵活：</p> <p>2.class,enum,structure都可以遵守协议。</p> <p>Extension也能遵守协议。利用它,我们不需要继承,也能够让系统的类也遵循我们的协议。</p> <p>例如：</p> <div class="highlighter-rouge"><pre class="highlight"><code>protocol myProtocol {
 func hello() -&gt; String
}
extension String:myProtocol{
 func hello() -&gt; String {
     return "hello world!"
 }
}
</code></pre></div> <p>我们还能够用这个特性来组织我们的代码结构,如下面的代码所示,将UITableViewDataSource的实现移到了Extension。使代码更清晰。</p> <div class="highlighter-rouge"><pre class="highlight"><code>// MARK: - UITableViewDataSource
extension MyViewcontroller: UITableViewDataSource {
// table view data source methods
}
</code></pre></div> <p>3.Protocol Oriented Programming</p> <p>随着Swift2.0的发布,面向协议编程正式也加入到了Swift的编程范式。Cool.</p> <p>这种编程方式通过怎样的语法特性支撑的呢？</p> <p>那就是我们能够对协议进行扩展,也就是我们能够提供协议的默认实现,能够为协议添加新的方法与实现。</p> <p>用前面的myProtocol为例子,我们在Swift里这样为它提供默认实现。</p> <div class="highlighter-rouge"><pre class="highlight"><code>extension myProtocol{
    func hello() -&gt; String {
     return "hello world!"
    }
}
</code></pre></div> <p>我们还能对系统原有的protocol进行扩展,大大增强了我们的想象空间。Swift2.0的实现也有很多地方用extension protocol的形式进行了重构。</p> <p>面向协议编程能够展开说很多,在这里这简单地介绍了语法。有兴趣的朋友可以参考下面的资料：</p> <p>Session 408: Protocol-Oriented Programming in Swift</p> <p>IF YOU’RE SUBCLASSING, YOU’RE DOING IT WRONG.</p> <p>7.Swift与Cocoa</p> <p>一门语言的的强大与否,除了自身优秀的特性外,很大一点还得依靠背后的框架。Swift直接采用苹果公司经营了很久的Cocoa框架。现在我们来看看使用Swift和Cocoa交互一些需要注意的地方。</p> <div class="highlighter-rouge"><pre class="highlight"><code>id与AnyObject
</code></pre></div> <p>在Swift中,没有id类型,Swift用一个名字叫AnyObject的protocol来代表任意类型的对象。</p> <div class="highlighter-rouge"><pre class="highlight"><code> id myObject = [[UITableViewCell alloc]init];

 var myObject: AnyObject = UITableViewCell()
</code></pre></div> <p>我们知道id的类型直到运行时才能被确定,如果我们向一个对象发送一条不能响应的消息,就会导致crash。</p> <p>我们可以利用Swift的语法特性来防止这样的错误:</p> <div class="highlighter-rouge"><pre class="highlight"><code>myObject.method?()
</code></pre></div> <p>如果myObject没有这个方法,就不会执行,类似检查delegate是否有实现代理方法。</p> <p>在Swift中,在AnyObject上获取的property都是optional的。</p> <ul> <li>闭包</li> </ul> <p>OC中的block在Swift中无缝地转换为闭包。函数实际上也是一种特殊的闭包。</p> <ul> <li>错误处理</li> </ul> <p>之前OC典型的错误处理步骤:</p> <div class="highlighter-rouge"><pre class="highlight"><code>NSFileManager *fileManager = [NSFileManager defaultManager];
NSURL *URL = [NSURL fileURLWithPath:@"/path/to/file"];
NSError *error = nil;
BOOL success = [fileManager removeItemAtURL:URL error:&amp;error];
if (!success) {
 NSLog(@"Error: %@", error.domain);
}
</code></pre></div> <p>在Swift中：</p> <div class="highlighter-rouge"><pre class="highlight"><code>let fileManager = NSFileManager.defaultManager()
let URL = NSURL.fileURLWithPath("/path/to/file")
do {
 try fileManager.removeItemAtURL(URL)
} catch let error as NSError {
 print("Error: \(error.domain)")
}
</code></pre></div> <ul> <li>KVO</li> </ul> <p>Swift支持KVO。但是KVO在Swift,个人觉得是不够优雅的,KVO在Swift只限支持继承NSObject的类,有其局限性,在这里就不介绍如何使用了。</p> <p>网上也出现了一些开源库来解决这样的问题。有兴趣可以参考一下:</p> <p>Observable-Swift</p> <p>KVO 在OS X中有Binding的能力,也就是我们能够将两个属性绑定在一起,一个属性变化,另外一个属性也会变化。对与UI和数据的同步更新很有帮助,也是MVVM架构的需求之一。之前已经眼馋这个特性很久了,虽然Swift没有原生带来支持,Swift支持的泛型编程给开源界带来许多新的想法。下面这个库就是实现binding的效果。</p> <p>Bond</p> <p>8.总结</p> <p>到这里就基本介绍完Swift当中最基本的语法和与Objective-C的对比和改进。</p> <p>事实上Swift的世界相比OC的世界还有很多新鲜的东西等待我们去发现和总结,Swift带来的多范式编程也将给我们编程的架构和代码的组织带来更来的思考。而Swift也是一个不断变化,不断革新的语言。相信未来的发展和稳定性会更让我们惊喜。这篇文章也将随着Swift的更新而不断更新,同时限制篇幅,突出重点。</p> <p>希望这篇文章能够给各位同行的小伙伴们快速了解和学习Swift提供一点帮助。有疏漏错误的地方欢迎直接提出。感谢。</p> <p>参考：</p> <p>《The Swift Programming Language》</p> <p>Apple Swift Blog</p> <p>Using Swift with Cocoa and Objective-C</p> </article> <div class="post-share"> <div class="container"> <a href="https://twitter.com/share?url=http://amazingw.github.com/2016/03/18/from-swift-2-oc.html&text=从Objective-C到Swift" target="_blank" class="post-share-icon twitter"></a> <a href="https://www.evernote.com/clip.action?url=http://amazingw.github.com/2016/03/18/from-swift-2-oc.html&title=从Objective-C到Swift" target="_blank" class="post-share-icon evernote"></a> <a href="http://service.weibo.com/share/share.php?url=http://amazingw.github.com/2016/03/18/from-swift-2-oc.html&title=从Objective-C到Swift" target="_blank" class="post-share-icon weibo"></a> </div> </div> <div class="comment container"> <div id="disqus_thread"> <a href=""></a> </div> </div> <div class="footer"> <div class="container"> <p class="footer-entry">All content is licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA</a></p> <p class="footer-entry">Buit with <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> and <a href="https://github.com/P233/3-Jekyll" target="_blank">3-Jekyll theme</a> • Hosted on <a href="https://pages.github.com/" target="_blank">Github</a></p> </div> </div> </main> <button id="menu"> <span id="menu-icons"></span> </button> <script src="/assets/js/jquery-2.1.3.min.js"></script> <script src="/assets/js/jquery.pjax.js"></script> <script src="/assets/js/nprogress.js"></script> <script src="/assets/js/main.js"></script> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-75184518-1', 'auto'); ga('send', 'pageview'); </script> </body> </html>
