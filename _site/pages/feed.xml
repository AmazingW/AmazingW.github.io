<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>AW的个人博客</title>
    <description>AW的个人博客
</description>
    <link>http://amazingw.github.com/</link>
    <atom:link href="http://amazingw.github.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 17 Mar 2016 17:36:41 +0800</pubDate>
    <lastBuildDate>Thu, 17 Mar 2016 17:36:41 +0800</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>win7服务</title>
        <description>&lt;p&gt;這是依據個人電腦,家庭使用的windows7系統服務的一些優化,關閉一些系統自帶的防火牆和安全的服務，家庭電腦使用不錯。大家使用看看~基本上優化後系統開機和執行速度很快了！&lt;/p&gt;

&lt;p&gt;Adaptive Brightness【禁用】&lt;/p&gt;

&lt;p&gt;監視氛圍光傳感器，以檢測氛圍光的變化並調節顯示器的亮度。如果此服務停止或被禁用，顯示器亮度將不根據照明條件進行調節。&lt;/p&gt;

&lt;p&gt;該服務的預設執行方式是手動，如果你沒有使用觸摸屏一類的智能調節屏幕亮度的設備，該功能就可以放心禁用。&lt;/p&gt;

&lt;p&gt;Application Experience【手動】&lt;/p&gt;

&lt;p&gt;在應用程序啟動時為應用程序處理應用程序兼容性緩存請求。&lt;/p&gt;

&lt;p&gt;該服務的預設執行方式是自動，建議手動。&lt;/p&gt;

&lt;p&gt;Application Information【手動】&lt;/p&gt;

&lt;p&gt;使用輔助管理權限便於交互式應用程序的執行。如果停止此服務，用戶將無法使用輔助管理權限啟動應用程序，而執行所需用戶任務可能需要這些權限。&lt;/p&gt;

&lt;p&gt;該服務的預設執行方式是手動，不建議更改。&lt;/p&gt;

&lt;p&gt;Application Layer Gateway Service【禁用】【待測試結果】&lt;/p&gt;

&lt;p&gt;為 Internet 連接共享提供第三方協議插件的支援，如果裝有第三方防火牆且不需要用ICS方式共享上網，完全可以禁用掉。&lt;/p&gt;

&lt;p&gt;Application Management【禁用】&lt;/p&gt;

&lt;p&gt;為通過組策略部署的軟件處理安裝、刪除以及枚舉請求。如果該服務被禁用，則用戶將不能安裝、刪除或枚舉通過組策略部署的軟件。如果此服務被禁用，則直接依賴於它的所有服務都將無法啟動。&lt;/p&gt;

&lt;p&gt;該服務預設的執行方式為手動，該功能主要適用於大型企業環境下的集中管理，因此家庭用戶可以放心禁用該服務。&lt;/p&gt;

&lt;p&gt;Ati External Event Utility【手動】&lt;/p&gt;

&lt;p&gt;裝了ATI顯卡驅動的就會有這個進程，建議手動。&lt;/p&gt;

&lt;p&gt;Background Intelligent Transfer Service【手動】&lt;/p&gt;

&lt;p&gt;使用空閒網路帶寬在後台傳送文件。如果該服務被禁用，則依賴於 BITS 的任何應用程序(如 Windows Update 或 MSN Explorer)將無法自動下載程序和其他信息。&lt;/p&gt;

&lt;p&gt;這個服務的主要用途還是用於 進行WindowsUpdate或者自動更新，如果是採用更新包來更新的話，完全可以禁用。&lt;/p&gt;

&lt;p&gt;Base Filtering Engine【禁用】【待測試結果】&lt;/p&gt;

&lt;p&gt;基本篩選引擎(BFE)是一種管理防火牆和 Internet 協議安全(IPsec)策略以及實施用戶模式篩選的服務。停止或禁用 BFE 服務將大大降低系統的安全。還將造成 IPsec 管理和防火牆應用程序產生不可預知的行為。&lt;/p&gt;

&lt;p&gt;同樣為系統防火牆，VPN以及IPsec提供依賴服務，同時也是系統安全方面的服務，如果使用第三方VPN撥號軟件並且不用系統的防火牆以及ICS共享上網，為了系統資源，關閉它吧，否則就別動它。&lt;/p&gt;

&lt;p&gt;BitLocker Drive Encryption Service【禁用】&lt;/p&gt;

&lt;p&gt;BDESVC 承載 BitLocker 驅動器加密服務。BitLocker 驅動器加密為操作系統提供安全啟動保障，並為 OS、固定卷和可移動卷提供全卷加密功能。使用此服務，BitLocker 可以提示用戶執行與已安裝卷相關的各種操作，並自動解鎖卷而無需用戶交互。此外，它還會將恢復信息存儲至 Active Directory (如果這種方法可用並且需要這樣做)，並確保使用最近的恢復證書。停止或禁用該服務可以防止用戶使用此功能。&lt;/p&gt;

&lt;p&gt;該服務的預設執行方式是手動，如果你沒有使用BitLocker設備，該功能就可以放心禁用。&lt;/p&gt;

&lt;p&gt;Block Level Backup Engine Service【手動】&lt;/p&gt;

&lt;p&gt;執行塊級備份和恢復的引擎。估計是和備份恢復方面用的服務，無任何依賴關係，預設是手動，也從來沒有看他啟動過。就放那吧，不用管了。&lt;/p&gt;

&lt;p&gt;Bluetooth Support Service【禁用】&lt;/p&gt;

&lt;p&gt;Bluetooth 服務支援發現和關聯遠端 Bluetooth 設備。停止或禁用此服務可能導致已安裝的 Bluetooth 設備無法正確操作，還會阻止發現和關聯新設備。&lt;/p&gt;

&lt;p&gt;該服務的預設執行方式是手動，如果你沒有使用藍牙設備，該功能就可以放心禁用。&lt;/p&gt;

&lt;p&gt;Certificate Propagation【禁用】&lt;/p&gt;

&lt;p&gt;為智能卡提供證書。該服務的預設執行方式是手動。如果你沒有使用智能卡，那麼可以放心禁用該服務。&lt;/p&gt;

&lt;p&gt;CNG Key Isolation【手動】&lt;/p&gt;

&lt;p&gt;CNG 密鑰隔離服務宿主在 LSA 進程中。如一般原則所要求，該服務為私鑰和相關加密操作提供密鑰進程隔離。該服務在與一般原則要求相一致的安全進程中存儲和使用生存期長的密鑰。如果 Wired AutoConfig/WLAN AutoConfig 兩個服務被打開，而且使用了 EAP(ExtensibleAuthentication Protocol)，那麼這個服務將被使用，建議不使用自動有線網路配置和無線網路的可以關掉。&lt;/p&gt;

&lt;p&gt;COM+ Event System【自動】&lt;/p&gt;

&lt;p&gt;支援系統事件通知服務 (SENS)，此服務為訂閱的組件對像模型 (COM) 組件提供自動分佈事件功能。如果停止此服務，SENS 將關閉，而且不能提供登錄和註銷通知。&lt;/p&gt;

&lt;p&gt;如果禁用此服務，顯式依賴此服務的其他服務都將無法啟動。&lt;/p&gt;

&lt;p&gt;一個很原始的古老服務，該服務的預設執行方式為自動，這是一個重要的系統服務，設為手動也會自動執行，設為禁用好像也沒什麼影響，但是日誌中會出現大量的錯誤。&lt;/p&gt;

&lt;p&gt;我們最好不要亂動。&lt;/p&gt;

&lt;p&gt;COM+ System Application【手動】&lt;/p&gt;

&lt;p&gt;管理基於組件對像模型 (COM+) 的組件的配置和跟蹤。如果停止該服務，則大多數基於COM+ 的組件將不能正常工作。如果禁用該服務，則任何明確依賴它的服務都將無法啟動。搞開發的比較清楚，以前的COM+程序甚至IIS/.NET中的應用都會用到這個服務。&lt;/p&gt;

&lt;p&gt;只要不設置為禁用就行了，基本上也是很少執行的服務。&lt;/p&gt;

&lt;p&gt;Computer Browser【禁用】&lt;/p&gt;

&lt;p&gt;維護網路上電腦的更新列表，並將列表提供給電腦指定瀏覽。如果服務停止，列表不會被更新或維護。如果服務被禁用，任何直接依賴於此服務的服務將無法啟動。該服務的預設執行方式為自動，不過如果你沒有使用局域網，這項服務可以設為禁用。就算要在局域網內使用，也只設為手動，因為說不准什麼時候會要用上，用的時候它會自個啟動。&lt;/p&gt;

&lt;p&gt;Credential Manager【手動】&lt;/p&gt;

&lt;p&gt;為用戶、應用程序和安全服務包提供憑據的安全存儲和檢索。&lt;/p&gt;

&lt;p&gt;該服務的預設執行方式是手動，建議保持預設。&lt;/p&gt;

&lt;p&gt;Cryptographic Services【自動】&lt;/p&gt;

&lt;p&gt;提供四種管理服務: 目錄數據庫服務，用於確認 Windows 文件的簽名和允許安裝新程序；受保護的根服務，用於從該電腦中添加與刪除受信任根證書頒發機構的證書；自動根證書更新服務，用於從 Windows Update 中檢索根證書和啟用 SSL 等方案；密鑰服務，用於協助註冊此電腦以獲取證書。如果此服務已停止，這些管理服務將無法正常執行。如果此服務已禁用，任何明確依賴它的服務將無法啟動。維護和管理系統的所有證書，密鑰以及安全數據庫。另外訪問一些網站所需要的服務，比如微軟的網站，WindowsUpdate，或者DRM的網站，很多時候它會提供和確認Windows文件的簽名信息。&lt;/p&gt;

&lt;p&gt;強烈建議也是必須不能去動它，永遠別想禁用這個服務。&lt;/p&gt;

&lt;p&gt;DCOM Server Process Launcher【自動】&lt;/p&gt;

&lt;p&gt;DCOMLAUNCH 服務可啟動響應對像激活請求的 COM 和 DCOM 服務器。如果此服務停止或禁用，則使用 COM 或 DCOM 的程序將無法正常工作。強烈建議您執行DCOMLAUNCH 服務。該服務的預設執行方式是自動，最好不要亂動。以前的DCOM服務，也就是遠端服務，是比COM+更基本的服務，看看註冊表就知道Windows系統中有多少DCOM組件，雖然禁用也沒什麼問題，但是臨時用到的設為手動的服務會無法自動啟動，而且任務欄的圖標也會消失不見，所以最好不要修改這個選項。&lt;/p&gt;

&lt;p&gt;Desktop Window Manager Session Manager【自動】&lt;/p&gt;

&lt;p&gt;提供桌面窗口管理器啟動和維護服務Aero風格必須的，所有AeroGlass和Flip3D效果均依賴這個服務。&lt;/p&gt;

&lt;p&gt;如果喜歡這個風格就要設為自動，否則就禁用吧。&lt;/p&gt;

&lt;p&gt;DHCP Client【自動】&lt;/p&gt;

&lt;p&gt;為此電腦註冊並更新 IP 地址。如果此服務停止，電腦將不能接收動態 IP 地址和DNS 更新。如果此服務被禁用，所有明確依賴它的服務都將不能啟動。&lt;/p&gt;

&lt;p&gt;該服務的預設執行方式是自動，如果是手動指定的IP，完全可以禁用。&lt;/p&gt;

&lt;p&gt;Diagnostic Policy Service【禁用】&lt;/p&gt;

&lt;p&gt;診斷策略服務啟用了 Windows 組件的問題檢測、疑難解答和解決方案。如果該服務被停止，診斷將不再執行。&lt;/p&gt;

&lt;p&gt;該服務的預設執行方式是自動，Vista或IE7有時會彈出對話框問你是否需要讓它幫忙找到故障的原因，只有1%的情況下它會幫忙修復Internet斷線的問題，建議禁用。&lt;/p&gt;

&lt;p&gt;Diagnostic Service Host【禁用】&lt;/p&gt;

&lt;p&gt;診斷服務主機被診斷策略服務用來承載需要在本地系統上下文中執行的診斷。如果停止該服務，則依賴於該服務的任何診斷將不再執行。&lt;/p&gt;

&lt;p&gt;這就是幫上面Diagnostic Policy Service 做具體事情的服務，會隨著上面的服務啟動，可以一起禁用。&lt;/p&gt;

&lt;p&gt;Diagnostic System Host【禁用】&lt;/p&gt;

&lt;p&gt;診斷系統主機被診斷策略服務用來承載需要在本地系統上下文中執行的診斷。如果停止該服務，則依賴於該服務的任何診斷將不再執行。&lt;/p&gt;

&lt;p&gt;基本和Diagnostic Policy Service/Diagnostic Service Host是同類，可以一起禁用。&lt;/p&gt;

&lt;p&gt;Disk Defragmenter【手動】&lt;/p&gt;

&lt;p&gt;提供磁盤碎片整理功能。&lt;/p&gt;

&lt;p&gt;該服務的預設執行方式是手動，建議保持預設。&lt;/p&gt;

&lt;p&gt;Distributed Link Tracking Client【禁用】&lt;/p&gt;

&lt;p&gt;維護某個電腦內或某個網路中的電腦的 NTFS 文件之間的鏈接。&lt;/p&gt;

&lt;p&gt;該服務的預設執行方式是自動，不過這個功能一般都用不上，完全可以放心禁用。&lt;/p&gt;

&lt;p&gt;Distributed Transaction Coordinator【手動】&lt;/p&gt;

&lt;p&gt;協調跨多個數據庫、消息隊列、文件系統等資源管理器的事務。如果停止此服務，這些事務將會失敗。如果禁用此服務，顯式依賴此服務的其他服務將無法啟動。&lt;/p&gt;

&lt;p&gt;很多應用以及SQL，ExchangeBiztalk等服務器軟件都依賴這個服務，可以不啟動它，但不要禁用它，建議手動。&lt;/p&gt;

&lt;p&gt;DNS Client【禁用】【待測試結果】&lt;/p&gt;

&lt;p&gt;DNS 客戶端服務(dnscache)緩存域名系統(DNS)名稱並註冊該電腦的完整電腦名稱。&lt;/p&gt;

&lt;p&gt;如果該服務被停止，將繼續解析 DNS 名稱。然而，將不緩存DNS 名稱的查詢結果，且不註冊電腦名稱。如果該服務被禁用，則任何明確依賴於它的服務都將無法啟動。該服務的預設執行方式是自動，如果是在域的環境中要設置為自動，但是這個服務可以洩露你瀏覽過哪些網站，所以一般用戶出於安全考慮，禁用了吧。&lt;/p&gt;

&lt;p&gt;Encrypting File System (EFS)【手動】&lt;/p&gt;

&lt;p&gt;提供用於在 NTFS 文件系統捲上存儲加密文件的核心文件加密技術。如果停止或禁用此服務，則應用程序將無法訪問加密的文件。&lt;/p&gt;

&lt;p&gt;該服務的預設執行方式是手動，建議保持預設。&lt;/p&gt;

&lt;p&gt;Extensible Authentication Protocol【手動】&lt;/p&gt;

&lt;p&gt;可擴展的身份驗證協議(EAP)服務在以下情況下提供網路身份驗證: 802.1x 有線和無線、VPN 和網路訪問保護(NAP)。EAP 在身份驗證過程中也提供網路訪問客戶端使用的應用程序編程接口(API)，包括無線客戶端和 VPN 客戶端。如果禁用此服務，該電腦將無法訪問需要 EAP 身份驗證的網路。如果禁用此服務，該電腦將無法訪問&lt;/p&gt;

&lt;p&gt;需要EAP身份驗證的網路。&lt;/p&gt;

&lt;p&gt;不用802.1x認證、無線網路或VPN可以不啟動它，不要禁用它，建議保持手動。&lt;/p&gt;

&lt;p&gt;Function Discovery Provider Host【禁用】&lt;/p&gt;

&lt;p&gt;FDPHOST 服務承載功能發現(FD)網路發現提供程序。這些 FD 提供程序為簡單服務發現協議(SSDP)和 Web 服務發現(WS-D)協議提供網路發現服務。使用 FD 時停止或禁用 FDPHOST 服務將禁用這些協議的網路發現。當該服務不可用時，使用 FD 和依靠這些發現協議的網路服務將無法找到網路服務或資源。&lt;/p&gt;

&lt;p&gt;PnP-X和SSDP相關，如果無相關設備就禁用了吧。&lt;/p&gt;

&lt;p&gt;Function Discovery Resource Publication【禁用】&lt;/p&gt;

&lt;p&gt;發佈該電腦以及連接到該電腦的資源，以便能夠在網路上發現這些資源。如果該服務被停止，將不再發佈網路資源，網路上的其他電腦將無法發現這些資源。&lt;/p&gt;

&lt;p&gt;PnP-X和SSDP相關，如果無相關設備就關了吧。&lt;/p&gt;

&lt;p&gt;Group Policy Client【自動】&lt;/p&gt;

&lt;p&gt;該服務負責通過組策略組件應用管理員為電腦和用戶配置的設置。如果停止或禁用該服務，將無法應用設置，並且將無法通過組策略管理應用程序和組件。如果停止或禁用該服務，依賴於組策略的任何組件或應用程序都將無法正常執行。&lt;/p&gt;

&lt;p&gt;系統重要服務，保持自動不變。&lt;/p&gt;

&lt;p&gt;Health Key and Certificate Management【手動】&lt;/p&gt;

&lt;p&gt;為網路訪問保護代理(NAPAgent)提供 X.509 證書和密鑰管理服務。使用 X.509 證書的強制技術在沒有此服務的情況下可能無法正常工作推測是NAP的一個服務，其中提到要實現一個HealthRegistrationAuthority機制，預設手動即可。&lt;/p&gt;

&lt;p&gt;HomeGroup Provider【禁用】&lt;/p&gt;

&lt;p&gt;執行與主組的配置和維護相關的網路任務。如果停止或禁用此服務，您的電腦將無法檢測到其他主組，且您的主組可能無法正常工作。建議您保持此服務的執行狀態。&lt;/p&gt;

&lt;p&gt;如果你不使用家庭群組來共享圖片視頻及文檔,那麼該服務可以禁用。&lt;/p&gt;

&lt;p&gt;Human Interface Device Access【手動】&lt;/p&gt;

&lt;p&gt;啟用對智能界面設備(HID)的通用輸入訪問，它激活並保存鍵盤、遠端控制和其它多媒體設備上的預先定義的熱按鈕。如果此服務被終止，由此服務控制的熱按鈕將不再執行。如果此服務被禁用，任何依賴它的服務將無法啟動。&lt;/p&gt;

&lt;p&gt;如果你不想你機器或筆記本鍵盤上面的那些特別的附加按鍵起作用、不用遊戲手柄之類,可以禁用這個服務。&lt;/p&gt;

&lt;p&gt;IKE and AuthIP IPsec Keying Modules【禁用】&lt;/p&gt;

&lt;p&gt;IKEEXT 服務托管 Internet 密鑰交換(IKE)和身份驗證 Internet 協議(AuthIP)鍵控模塊。這些鍵控模塊用於 Internet 協議安全(IPSec)中的身份驗證和密鑰交換。停止或禁用 IKEEXT 服務將禁用與對等電腦的IKE/AuthIP 密鑰交換。通常將 IPSec 配置為使用 IKE 或 AuthIP，因此停止或禁用 IKEEXT 服務將導致 IPSec 故障並且危及系統的安全。強烈建議執行 IKEEXT 服務。&lt;/p&gt;

&lt;p&gt;主要是針對VPN等網路環境的進行認證。不用VPN或用第三方VPN撥號的話可以禁用。&lt;/p&gt;

&lt;p&gt;[未完]&lt;/p&gt;

&lt;p&gt;Windows 7系統服務詳解及優化方法(中)&lt;/p&gt;

&lt;p&gt;Interactive Services Detection【手動】&lt;/p&gt;

&lt;p&gt;啟用交互式服務的用戶輸入的用戶通知，這樣當交互式服務創建的對話框出現時可以訪問這些對話框。如果此服務已停止，將不再有新的交互式服務對話框通知，而且可能再也無法訪問交互式服務對話框。如果此服務已禁用，則不再有新的交互式服務對話框通知，也無法訪問這些對話框。&lt;/p&gt;

&lt;p&gt;我也不清楚什麼算交互式服務，預設也是手動，保持預設吧。&lt;/p&gt;

&lt;p&gt;Internet Connection Sharing (ICS)【禁用】&lt;/p&gt;

&lt;p&gt;為家庭和小型辦公網路提供網路地址轉換、尋址、名稱解析和/或入侵保護服務。該服務的預設執行方式是禁用，如果你不打算讓這台電腦充當ICS主機，那麼該服務可以禁用，否則需要啟用。&lt;/p&gt;

&lt;p&gt;IP Helper【禁用】&lt;/p&gt;

&lt;p&gt;在 IPv4 網路上提供自動的 IPv6 連接。如果停止此服務，則在電腦連接到本地 IPv6 網路時，該電腦將只具有 IPv6 連接。主要是提供IPv6的支援，說白了就是讓IPv4和IPv6相互兼容，現在的情況下不是特別需要，其實設置成禁用也無妨。&lt;/p&gt;

&lt;p&gt;IPsec Policy Agent【禁用】&lt;/p&gt;

&lt;p&gt;Internet 協議安全(IPSec)支援網路級別的對等身份驗證、數據原始身份驗證、數據完整性、數據機密性(加密)以及重播保護。此服務強制執行通過 IP 安全策略管理單元或命令行工具 “netsh ipsec” 創建的 IPSec 策略。停止此服務時，如果策略需要連接使用 IPSec，可能會遇到網路連接問題。同樣，此服務停止時，Windows 防火牆的遠端管理也不再可用。此服務強制執行通過 IP 安全策略管理單元或命令行工具 “netshipsec” 創建的 IPSec策略。停止此服務時，如果策略需要連接使用 IPSec，可能會遇到網路連接問題。同樣，此服務停止時，Windows 防火牆的遠端管理也不再可用。&lt;/p&gt;

&lt;p&gt;某些公司的網路環境要求必須打開，它提供一個TCP/IP網路上客戶端和服務器之間端到端的安全連接。其他的情況建議設置成禁用。&lt;/p&gt;

&lt;p&gt;KtmRm for Distributed Transaction Coordinator【手動】&lt;/p&gt;

&lt;p&gt;協調分佈式事務處理協調器(MSDTC)和內核事務管理器(KTM)之間的事務。如果不需要，建議保持該服務的停止狀態。如果需要，MSDTC 和 KTM 將自動啟動該服務。&lt;/p&gt;

&lt;p&gt;如果此服務已禁用，任何與內核資源管理器交互的 MSDTC 事務將失敗，並且任何顯式依賴它的服務將無法啟動。&lt;/p&gt;

&lt;p&gt;協調 MSDTC 和核心事務管理器(KTM)之間的事務。Vista提供的另外一種事務服務，對開發人員來說是比較有用，對於一般的用戶或者非開發人員來說，設置成手動。&lt;/p&gt;

&lt;p&gt;Link-Layer Topology Discovery Mapper【手動】&lt;/p&gt;

&lt;p&gt;創建網路映射，它由 PC 和設備拓撲(連接)信息以及說明每個 PC 和設備的元數據組成。如果禁用此服務，則網路映射將不能正常工作。&lt;/p&gt;

&lt;p&gt;應該是支援LLTD(LinkLayerTopologyDiscovery) 技術，可以精確地顯示支援LLTD的設備在網路結構中的位置，比如Vista的無線地圖 ，保持預設手動。&lt;/p&gt;

&lt;p&gt;Microsoft .NET Framework NGEN v2.0.50727_X86【手動】&lt;/p&gt;

&lt;p&gt;Microsoft .NET Framework NGEN&lt;/p&gt;

&lt;p&gt;NET開發人員都知道 NGEN的用法，保持預設的手動即可，以後會有很多基於.NET FX3的應用，那麼這個服務會有用的。&lt;/p&gt;

&lt;p&gt;Microsoft iSCSI Initiator Service【禁用】&lt;/p&gt;

&lt;p&gt;管理從這台電腦到遠端 iSCSI 目標設備的 Internet SCSI (iSCSI)會話。如果該服務已停止，則該電腦將無法登錄或訪問 iSCSI 目標設備。如果該服務已禁用，則所有顯式依賴於該服務的服務將不會啟動。&lt;/p&gt;

&lt;p&gt;如果本機沒有iSCSI設備也不需要連接和訪問遠端iSCSI設備，設置成禁用。&lt;/p&gt;

&lt;p&gt;Microsoft Software Shadow Copy Provider【禁用】&lt;/p&gt;

&lt;p&gt;管理卷影復***務製作的基於軟件的卷影副本。如果該服務被停止，將無法管理基於軟件的卷影副本。如果該服務被禁用，任何依賴它的服務將無法啟動。&lt;/p&gt;

&lt;p&gt;卷影拷貝，如果不需要就可以設為禁用，一般用戶基本都不會用到。&lt;/p&gt;

&lt;p&gt;Multimedia Class Scheduler【自動】&lt;/p&gt;

&lt;p&gt;基於系統範圍內的任務優先級啟用工作的相對優先級。這主要適用於多媒體應用程序。如果此服務停止，個別任務將使用其預設的優先級。主要是針對一些多媒體應用的音／視頻流設置優先級，禁用可能會導致聲卡功能出現問題，建議打開這個服務，設成手動一般也會自動啟動。&lt;/p&gt;

&lt;p&gt;Net.Tcp Port Sharing Service【禁用】&lt;/p&gt;

&lt;p&gt;提供通過 net.tcp 協議共享 TCP 端口的功能。&lt;/p&gt;

&lt;p&gt;WCF要用的，一般用戶和非開發人員，還是禁用就行了。&lt;/p&gt;

&lt;p&gt;Netlogon【手動】&lt;/p&gt;

&lt;p&gt;為用戶和服務身份驗證維護此電腦和域控制器之間的安全通道。如果此服務被停用，電腦可能無法驗證用戶和服務身份並且域控制器無法註冊DNS 記錄。如果此服務被禁用，任何依賴它的服務將無法啟動。&lt;/p&gt;

&lt;p&gt;登陸活動目錄時，和域服務通訊驗證的一個服務，一般驗證通過之後，域服務器會註冊你的DNS記錄，推送軟件補丁和策略等等，登陸域會用到它。工作組環境可以設為禁用。&lt;/p&gt;

&lt;p&gt;Network Access Protection Agent【手動】&lt;/p&gt;

&lt;p&gt;網路訪問保護(NAP)代理服務收集和管理網路上客戶端電腦的健康信息。NAP 代理收集的信息用於確保客戶端電腦具有所需的軟件和設置。如果客戶端電腦與健康策略不兼容，則可以為其提供受限的網路訪問權限，直至更新其配置。根據健康策略的配置，可能自動更新客戶端電腦，以便用戶可以迅速重新獲取完全網路訪問權限，無須手動更新他們的電腦。&lt;/p&gt;

&lt;p&gt;在客戶端電腦上啟用網路訪問保護(NAP)功能，這是NAP架構中的客戶端，預設設置手動即可。&lt;/p&gt;

&lt;p&gt;Network Connections【手動】&lt;/p&gt;

&lt;p&gt;管理「網路和撥號連接」文件夾中對象，在其中您可以查看局域網和遠端連接。當你點擊網路和撥號連接時這個服務就開始工作，主要是獲得局域網和遠端連接的對象&lt;/p&gt;

&lt;p&gt;，只要你聯網這個服務就會啟動。不要關閉它。&lt;/p&gt;

&lt;p&gt;Network List Service【手動】&lt;/p&gt;

&lt;p&gt;識別電腦已連接的網路，收集和存儲這些網路的屬性，並在更改這些屬性時通知應用程序。&lt;/p&gt;

&lt;p&gt;這個服務是列舉現有的網路，展示目前的連接狀態。關閉它會導致網路不正常，所以不要去動它。&lt;/p&gt;

&lt;p&gt;Network Location Awareness【自動】&lt;/p&gt;

&lt;p&gt;收集和存儲網路的配置信息，並在此信息被修改時向程序發出通知。如果停止此服務，則配置信息可能不可用；如果禁用此服務，則顯式依賴此服務的所有服務都將無法啟動。就是NLA，能夠很好的支援和標示多網卡，或者是你從家庭、個人、公司的網路中進行切換和變化時，給你提供增強的功能，大多數情況會隨著&lt;/p&gt;

&lt;p&gt;NetworkConnections自動啟動。&lt;/p&gt;

&lt;p&gt;和XP的NLA不同，關閉它網路正常但是會提示沒插網線，最好別去動它。&lt;/p&gt;

&lt;p&gt;Network Store Interface Service【自動】&lt;/p&gt;

&lt;p&gt;此服務向用戶模式客戶端發送網路通知(例如，添加/刪除接口等)。停止此服務將導致丟失網路連接。如果禁用此服務，則顯式依賴此服務的所有其他服務都將無法啟動。&lt;/p&gt;

&lt;p&gt;這是支援NLA的一個服務，比如保存每個網路的 Profile，所以它的執行狀態會和NLA相同，最好別去動它。&lt;/p&gt;

&lt;p&gt;Offline Files【禁用】&lt;/p&gt;

&lt;p&gt;脫機文件服務在脫機文件緩存中執行維護活動，響應用戶登錄和註銷事件，實現公共 API 的內部部分，並將相關的事件分配給關心脫機文件活動和緩存更改的用戶。&lt;/p&gt;

&lt;p&gt;脫機文件服務，使用這個功能系統會將網路上的共享內容在本地進行緩存，可以禁用。&lt;/p&gt;

&lt;p&gt;Peer Name Resolution Protocol【手動】&lt;/p&gt;

&lt;p&gt;使用對等名稱解析協議(PNRP)在 Internet 上啟用無服務器對等名稱解析。如果禁用該功能，則某些對等應用程序和協作應用程序(如遠端協助)可能無法執行。&lt;/p&gt;

&lt;p&gt;如果你不嘗試WCF的P2P功能或開發，那麼連同下面兩個服務都可以禁用。&lt;/p&gt;

&lt;p&gt;Peer Networking Grouping&lt;/p&gt;

&lt;p&gt;Peer Networking Identity Manager&lt;/p&gt;

&lt;p&gt;Performance Logs &amp;amp; Alerts【手動】&lt;/p&gt;

&lt;p&gt;性能日誌和警報根據預配置的計劃參數從本地或遠端電腦收集性能數據，然後將該數據寫入日誌或觸發警報。如果停止此服務，將不收集性能信息。如果禁用此服務，則明確依賴它的所有服務將無法啟動。&lt;/p&gt;

&lt;p&gt;EventLog和任務調度器等多個服務會用到它，個人認為它也是比較耗費資源的，但不建議設置成禁用，手動即可。&lt;/p&gt;

&lt;p&gt;Plug and Play【自動】&lt;/p&gt;

&lt;p&gt;使電腦在極少或沒有用戶輸入的情況下能識別並適應硬件的更改。終止或禁用此服務會造成系統不穩定。&lt;/p&gt;

&lt;p&gt;即插即用，最基本的服務之一，想關也關不了。&lt;/p&gt;

&lt;p&gt;PnP-X IP Bus Enumerator【禁用】&lt;/p&gt;

&lt;p&gt;PnP-X 總線枚舉器服務管理虛擬網路總線。該服務使用 SSDP/WS 發現協議來發現網路連接設備並使其存在於 PnP 中。如果停止或禁用此服務，則NCD 設備將不會繼續保持在 PnP 中。所有基於 pnpx 的方案都將停止執行。PnP-X 總線枚舉服務器-Windows ConnectNow(WCN)，即微軟網路和裝置平台的組件之一，它是即插即用&lt;/p&gt;

&lt;p&gt;的擴展，支援某些聯網的智能家電裝置(比如能聯網的電飯鍋、冰箱)連接到你的 PC上面。&lt;/p&gt;

&lt;p&gt;目前還用不上， 禁用它！&lt;/p&gt;

&lt;p&gt;PNRP Machine Name Publication Service【手動】&lt;/p&gt;

&lt;p&gt;此服務使用對等名稱解析協議發佈電腦名稱。配置是通過 Netsh 上下文「p2p pnrp peer」管理的。&lt;/p&gt;

&lt;p&gt;這個是用來對P2P網路中發佈服務器進行命名解析的，一般不需要它。預設即可。&lt;/p&gt;

&lt;p&gt;Portable Device Enumerator Service【禁用】&lt;/p&gt;

&lt;p&gt;強制可移動大容量存儲設備的組策略。使應用程序(如 Windows Media Player 和圖像導入嚮導)能夠使用可移動大容量存儲設備傳輸和同步內容。&lt;/p&gt;

&lt;p&gt;如不需要同步建議關閉。&lt;/p&gt;

&lt;p&gt;Power【自動】&lt;/p&gt;

&lt;p&gt;管理電源策略和電源策略通知傳遞。&lt;/p&gt;

&lt;p&gt;該服務的預設執行方式是自動，保持預設。&lt;/p&gt;

&lt;p&gt;Print Spooler【禁用】&lt;/p&gt;

&lt;p&gt;將文件加載到內存供稍後打印&lt;/p&gt;

&lt;p&gt;不用多說了，有打印機（包括虛擬的）就開，沒有就關。&lt;/p&gt;

&lt;p&gt;Problem Reports and Solutions Control Panel Support【禁用】&lt;/p&gt;

&lt;p&gt;此服務為查看、發送和刪除「問題報告和解決方案」控制面板的系統級問題報告提供支援。&lt;/p&gt;

&lt;p&gt;開了它基本也解決不了你電腦出的問題。禁用吧。&lt;/p&gt;

&lt;p&gt;Program Compatibility Assistant Service【自動】&lt;/p&gt;

&lt;p&gt;此服務為程序兼容性助手(PCA)提供支援。PCA 監視由用戶安裝和執行的程序，並檢測已知兼容性問題。如果停止此服務，PCA 將無法正常執行。&lt;/p&gt;

&lt;p&gt;如果你使用到 Program CompatibilityAssistant或者需要將你的程序設置成兼容模式執行，比如執行在Win98 或 Windows2000的方式下，就修改成自動，強烈建議設置為自動。&lt;/p&gt;

&lt;p&gt;Protected Storage【手動】&lt;/p&gt;

&lt;p&gt;為敏感數據(如密碼)提供保護存儲，以防止未授權的服務、進程或用戶訪問。&lt;/p&gt;

&lt;p&gt;2000/XP流傳 下來的服務，儘管用處不大，但為了安全還是保留著吧，禁用或手動均可。&lt;/p&gt;

&lt;p&gt;Quality Windows Audio Video Experience【禁用】&lt;/p&gt;

&lt;p&gt;優質 Windows 音頻視頻體驗(qWave)是用於 IP 家庭網路上的音頻視頻***流應用程序的網路平台。通過確保 AV 應用程序的網路服務質量(QoS)，qWave 增強了 AV 流的性能和可靠性。它提供了許可控制機制、執行時監視和實施、應用程序反饋以及流量優先順序。&lt;/p&gt;

&lt;p&gt;主要用於改善和加強IP網路上的音頻視頻流的傳輸和播放質量，控制流量，個人感覺這個不起什麼作用，支援這樣技術的網路服務也不多。還是系統資源比較重要，禁用它。&lt;/p&gt;

&lt;p&gt;Remote Access Auto Connection Manager【手動】&lt;/p&gt;

&lt;p&gt;只要程序引用遠端 DNS 或 NetBIOS 名稱或地址，就創建一個到遠端網路的連接。一般ADSL拔號和VPN接入都會用到這個服務。&lt;/p&gt;

&lt;p&gt;如果設置成禁用，就建不了連 接了。還是手動比較好。&lt;/p&gt;

&lt;p&gt;Remote Access Connection Manager【手動】&lt;/p&gt;

&lt;p&gt;管理從這台電腦到 Internet 或其他遠端網路的撥號和虛擬專用網路(VPN)連接。如果禁用該項服務，則明確依賴該服務的任何服務都將無法啟動。&lt;/p&gt;

&lt;p&gt;創建連接的時候使用， ADSL/VPN/其他什麼撥號網路都會用到這個服務。關了的話就不能上網了，保持預設。&lt;/p&gt;

&lt;p&gt;Remote Procedure Call (RPC)【自動】&lt;/p&gt;

&lt;p&gt;RPCSS 服務是 COM 和 DCOM 服務器的服務控制管理器。它執行 COM 和 DCOM 服務器的對象激活請求、對像導出程序解析和分佈式垃圾收集。如果此服務被停用或禁用，則使用 COM 或 DCOM 的程序將無法正常工作。強烈建議您讓 RPCSS 服務執行別動這個，系統重要服務。&lt;/p&gt;

&lt;p&gt;Remote Procedure Call (RPC) Locator【手動】&lt;/p&gt;

&lt;p&gt;在 Windows 2003 和 Windows 的早期版本中，遠端過程調用(RPC)定位器服務可管理 RPC 名稱服務數據庫。在 Windows Vista 和 Windows 的更新版本中，此服務不提供任何功能，但可用於應用程序兼容性。&lt;/p&gt;

&lt;p&gt;配合RPC的服務，可以設置手動，但不建議設置成禁用。&lt;/p&gt;

&lt;p&gt;Remote Registry【禁用】&lt;/p&gt;

&lt;p&gt;使遠端用戶能修改此電腦上的註冊表設置。如果此服務被終止，只有此電腦上的用戶才能修改註冊表。如果此服務被禁用，任何依賴它的服務將無法啟動。&lt;/p&gt;

&lt;p&gt;家庭個人用戶最好禁用 此服務，公司管理就需要打開了。&lt;/p&gt;

&lt;p&gt;Routing and Remote Access【禁用】&lt;/p&gt;

&lt;p&gt;在局域網以及廣域網環境中為企業提供路由服務。&lt;/p&gt;

&lt;p&gt;提供路由服務的。不用就關。&lt;/p&gt;

&lt;p&gt;RPC Endpoint Mapper【自動】&lt;/p&gt;

&lt;p&gt;解析 RPC 接口標識符以傳輸端點。如果此服務被停止或禁用，使用遠端過程調用(RPC)服務的程序將無法正常執行。&lt;/p&gt;

&lt;p&gt;該服務的預設執行方式是自動，不要去改動它。&lt;/p&gt;

&lt;p&gt;Secondary Logon【禁用】&lt;/p&gt;

&lt;p&gt;在不同憑據下啟用啟動過程。如果此服務被停止，這種類型的登錄訪問將不可用。如果此服務被禁用，任何明確依賴它的服務都將不能啟動。&lt;/p&gt;

&lt;p&gt;允許一台機器同時有兩個用戶登錄，個人 應用基本不需要，禁用。&lt;/p&gt;

&lt;p&gt;Secure Socket Tunneling Protocol Service【手動】&lt;/p&gt;

&lt;p&gt;提供使用 VPN 連接到遠端電腦的安全套接字隧道協議(SSTP)的支援。如果該服務被禁用，則用戶將無法使用 SSTP 訪問遠端服務器。&lt;/p&gt;

&lt;p&gt;這個服務主要是VPN連接服務的，如果用 第三方VPN客戶端，可以關閉，但是RemoteAccessConnectionManager這個服務依賴這個服務，還是別動吧。&lt;/p&gt;

&lt;p&gt;Security Accounts Manager【自動】&lt;/p&gt;

&lt;p&gt;啟動此服務將向其他服務發出信號: 安全帳戶管理器(SAM)已準備就緒，可以接受請求。禁用此服務將導致在 SAM 準備就緒時，無法通知系統中的其他服務，從而可能導致這些服務無法正確啟動。不應禁用此服務。禁 用此服務將導致在 SAM 準備就緒時，無法通知系統中的其他服務，從而可能導致這些服 務無法正確啟動。不應禁用此服務。&lt;/p&gt;

&lt;p&gt;系統的安全賬戶管理服務，關了就不能添加用戶，修改 用戶密碼等用戶操作了，建議預設別動它&lt;/p&gt;
</description>
        <pubDate>Thu, 17 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://amazingw.github.com/2016/03/17/win7-service.html</link>
        <guid isPermaLink="true">http://amazingw.github.com/2016/03/17/win7-service.html</guid>
        
        <category>win7</category>
        
        <category>service</category>
        
        
        <category>工具</category>
        
      </item>
    
      <item>
        <title>github遇到问题及解决</title>
        <description>&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如果输入
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    $ git remote add origin git@github.com:djqiang（github帐号名）/gitdemo（项目名）.git

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;提示出错信息：
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    fatal: remote origin already exists.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;解决办法如下：
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    $ git remote rm origin
    $ git remote add origin git@github.com:djqiang/gitdemo.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如果输入
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    $ git remote rm origin
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;还是报错的话
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    error: Could not remove config section &#39;remote.origin&#39;.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们需要修改gitconfig文件的内容&lt;/p&gt;

&lt;p&gt;找到你的github的安装路径，我的是C:\Users\ASUS\AppData\Local\GitHub\PortableGit_ca477551eeb4aea0e4ae9fcd3358bd96720bb5c8\etc&lt;/p&gt;

&lt;p&gt;找到一个名为gitconfig的文件，打开它把里面的[remote “origin”]那一行删掉就好了！&lt;/p&gt;

&lt;p&gt;如果输入$ ssh -T git@github.com
出现错误提示：Permission denied (publickey).因为新生成的key不能加入ssh就会导致连接不上github。&lt;/p&gt;

&lt;p&gt;id_rsa.pub 在~/.ssh这个文件夹下&lt;/p&gt;

&lt;p&gt;解决办法如下：&lt;/p&gt;

&lt;p&gt;1、先输入$ ssh-agent，再输入$ ssh-add ~/.ssh/id_key，这样就可以了。&lt;/p&gt;

&lt;p&gt;2、如果还是不行的话，输入ssh-add ~/.ssh/id_key 命令后出现报错Could not open a connection to your authentication agent.解决方法是key用Git Gui的ssh工具生成，这样生成的时候key就直接保存在ssh中了，不需要再ssh-add命令加入了，其它的user，token等配置都用命令行来做。&lt;/p&gt;

&lt;p&gt;3、最好检查一下在你复制id_rsa.pub文件的内容时有没有产生多余的空格或空行，有些编辑器会帮你添加这些的。&lt;/p&gt;

&lt;p&gt;如果输入$ git push origin master&lt;/p&gt;

&lt;p&gt;提示出错信息：error:failed to push som refs to …….&lt;/p&gt;

&lt;p&gt;解决办法如下：&lt;/p&gt;

&lt;p&gt;1、先输入$ git pull origin master //先把远程服务器github上面的文件拉下来&lt;/p&gt;

&lt;p&gt;2、再输入$ git push origin master&lt;/p&gt;

&lt;p&gt;3、如果出现报错 fatal: Couldn’t find remote ref master或者fatal: ‘origin’ does not appear to be a git repository以及fatal: Could not read from remote repository.&lt;/p&gt;

&lt;p&gt;4、则需要重新输入$ git remote add origingit@github.com:djqiang/gitdemo.git&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;使用git在本地创建一个项目的过程
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    $ makdir ~/hello-world    //创建一个项目hello-world
    $ cd ~/hello-world       //打开这个项目
    $ git init             //初始化
    $ touch README
    $ git add README        //更新README文件
    $ git commit -m &#39;first commit&#39;     //提交更新，并注释信息“first commit”
    $ git remote add origin git@github.com:defnngj/hello-world.git     //连接远程github项目
    $ git push -u origin master     //将本地项目更新到github项目上去
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;gitconfig配置文件&lt;/p&gt;

&lt;p&gt;Git有一个工具被称为git config，它允许你获得和设置配置变量；这些变量可以控制Git的外观和操作的各个方面。这些变量可以被存储在三个不同的位置：
 1./etc/gitconfig 文件：包含了适用于系统所有用户和所有库的值。如果你传递参数选项’–system’ 给 git config，它将明确的读和写这个文件。
 2.~/.gitconfig 文件 ：具体到你的用户。你可以通过传递–global 选项使Git 读或写这个特定的文件。
 3.位于git目录的config文件 (也就是 .git/config) ：无论你当前在用的库是什么，特定指向该单一的库。每个级别重写前一个级别的值。因此，在.git/config中的值覆盖了在/etc/gitconfig中的同一个值。
    在Windows系统中，Git在$HOME目录中查找.gitconfig文件（对大多数人来说，位于C:\Documents and Settings$USER下）。它也会查找/etc/gitconfig，尽管它是相对于Msys 根目录的。这可能是你在Windows中运行安装程序时决定安装Git的任何地方。&lt;/p&gt;

&lt;p&gt;配置相关信息：&lt;/p&gt;

&lt;p&gt;当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    　　$ git config --global user.name &quot;John Doe&quot;

    　　$ git config --global user.email johndoe@example.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你的编辑器(Your Editor)&lt;/p&gt;

&lt;p&gt;现在，你的标识已经设置，你可以配置你的缺省文本编辑器，Git在需要你输入一些消息时会使用该文本编辑器。缺省情况下，Git使用你的系统的缺省编辑器，这通常可能是vi 或者 vim。如果你想使用一个不同的文本编辑器，例如Emacs，你可以做如下操作：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    　　$ git config --global core.editor emacs
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;检查你的设置(Checking Your Settings)&lt;/p&gt;

&lt;p&gt;如果你想检查你的设置，你可以使用 git config –list 命令来列出Git可以在该处找到的所有的设置:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;　　$ git config --list
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你也可以查看Git认为的一个特定的关键字目前的值，使用如下命令 git config {key}:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;　　$ git config user.name
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;获取帮助(Getting help)&lt;/p&gt;

&lt;p&gt;如果当你在使用Git时需要帮助，有三种方法可以获得任何git命令的手册页(manpage)帮助信息:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    　　$ git help &amp;lt;verb&amp;gt;

    　　$ git &amp;lt;verb&amp;gt; --help

    　　$ man git-&amp;lt;verb&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;例如，你可以运行如下命令获取对config命令的手册页帮助:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;　　$ git help config
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 17 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://amazingw.github.com/2016/03/17/issues-when-using-github.html</link>
        <guid isPermaLink="true">http://amazingw.github.com/2016/03/17/issues-when-using-github.html</guid>
        
        <category>github</category>
        
        
        <category>工具</category>
        
      </item>
    
      <item>
        <title>cocopods 出现更新错误</title>
        <description>&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2015-09-18 10:39:02.521 ruby[3178:88741] [MT] DVTAssertions: ASSERTION FAILURE in /Library/Caches/com.apple.xbs/Sources/IDEFrameworks/IDEFrameworks-8227/IDEFoundation/Initialization/IDEInitialization.m:590
Details:  Assertion failed: _initializationCompletedSuccessfully
Function: BOOL IDEIsInitializedForUserInteraction()
Thread:   &amp;lt;NSThread: 0x7f99f4dd77d0&amp;gt;{number = 1, name = main}
Hints: None
Backtrace:
  0  0x000000010dcfea5c -[DVTAssertionHandler handleFailureInFunction:fileName:lineNumber:assertionSignature:messageFormat:arguments:] (in DVTFoundation)
  1  0x000000010dcfe1e9 _DVTAssertionHandler (in DVTFoundation)
  2  0x000000010dcfe455 _DVTAssertionFailureHandler (in DVTFoundation)
  3  0x000000010dcfe3b7 _DVTAssertionFailureHandler (in DVTFoundation)
  4  0x000000010f242f5c IDEIsInitializedForUserInteraction (in IDEFoundation)
  5  0x0000000111e42eb9 +[PBXProject projectWithFile:errorHandler:readOnly:] (in DevToolsCore)
  6  0x0000000111e44a3e +[PBXProject projectWithFile:errorHandler:] (in DevToolsCore)
  7  0x00007fff93ef1f44 ffi_call_unix64 (in libffi.dylib)
Abort trap: 6
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;解决办法1：
先卸载cocopods&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo gem uninstall cocoapods
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;再安装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo gem install cocoapods
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;再&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pod install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 17 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://amazingw.github.com/2016/03/17/error-of-cocopods.html</link>
        <guid isPermaLink="true">http://amazingw.github.com/2016/03/17/error-of-cocopods.html</guid>
        
        <category>iOS</category>
        
        
        <category>工具</category>
        
      </item>
    
      <item>
        <title>mysql中explain用法详解</title>
        <description>&lt;p&gt;如果在select语句前放上关键词explain，mysql将解释它如何处理select，提供有关表如何联接和联接的次序。&lt;/p&gt;

&lt;p&gt;explain的每个输出行提供一个表的相关信息，并且每个行包括下面的列：&lt;/p&gt;

&lt;p&gt;1，id   select识别符。这是select的查询序列号。&lt;/p&gt;

&lt;p&gt;2，select_type 可以为一下任何一种类型
    simple  简单select(不使用union或子查询)
    primary   最外面的select
    union    union中的第二个或后面的select语句
    dependent union  union中的第二个或后面的select语句，取决于外面的查询
    union result  union的结果。
    subquery 子查询中的第一个select
    dependent subquery  子查询中的第一个select，取决于外面的查询
    derived    导出表的select(from子句的子查询)&lt;/p&gt;

&lt;p&gt;3，table  输出的行所引用的表。&lt;/p&gt;

&lt;p&gt;4，type  联接类型。下面给出各种联接类型，按照从最佳类型到最坏类型进行排序：
    system  表仅有一行(=系统表)。这是const联接类型的一个特例。
    const  表最多有一个匹配行，它将在查询开始时被读取。因为仅有一行，在这行的列值可被优化器剩余部分认为是常数。const表很快，因为它们只读取一次！
    eq_ref 对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了const类型。它用在一个索引的所有部分被联接使用并且索引是unique或primary key
    ref  对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取。如果联接只使用键的最左边的前缀，或如果键不是unique或primary key（换句话说，如果联接不能基于关键字选择单个行的话），则使用ref。如果使用的键仅仅匹配少量行，该联接类型是不错的。
    ref可以用于使用=或&amp;lt;=&amp;gt;操作符的带索引的列。
    possible_keys 如果该列是null，则没有相关的索引。在这种情况下，可以通过检查where子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用explain检查查询key 列显示mysql实际决定使用的键（索引）。如果没有选择索引，键是null。要想强制mysql使用或忽视possible_keys列中的索引，在查询中使用force index、use index或者ignore index。&lt;/p&gt;

&lt;p&gt;5，rows  rows列显示mysql认为它执行查询时必须检查的行数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;以上简单介绍了mysql中explain语句的用法，希望对大家有所帮助。

对mysql explain讲的比较清楚的

在 explain的帮助下，您就知道什么时候该给表添加索引，以使用索引来查找记录从而让select 运行更快。
如果由于不恰当使用索引而引起一些问题的话，可以运行 analyze table来更新该表的统计信息，例如键的基数，它能帮您在优化方面做出更好的选择。

explain 返回了一行记录，它包括了 select语句中用到的各个表的信息。这些表在结果中按照mysql即将执行的查询中读取的顺序列出来。mysql用一次扫描多次连接（single- sweep,multi-join）的方法来解决连接。这意味着mysql从第一个表中读取一条记录，然后在第二个表中查找到对应的记录，然后在第三个表中查找，依次类推。当所有的表都扫描完了，它输出选择的字段并且回溯所有的表，直到找不到为止，因为有的表中可能有多条匹配的记录下一条记录将从该表读取，再从下一个表开始继续处理。
在mysql version 4.1中，explain输出的结果格式改变了，使得它更适合例如 union语句、子查询以及派生表的结构。更令人注意的是，它新增了2个字段： id和 select_type。当你使用早于mysql4.1的版本就看不到这些字段了。
explain结果的每行记录显示了每个表的相关信息，每行记录都包含以下几个字段：

id
本次 select 的标识符。在查询中每个 select都有一个顺序的数值。
select_type
select 的类型，可能会有以下几种：
simple: 简单的 select （没有使用 union或子查询）

primary: 最外层的 select。

union: 第二层，在select 之后使用了 union。

dependent union: union 语句中的第二个select，依赖于外部子查询

subquery: 子查询中的第一个 select

dependent subquery: 子查询中的第一个 subquery依赖于外部的子查询

derived: 派生表 select（from子句中的子查询）

table
记录查询引用的表。

type
表连接类型。以下列出了各种不同类型的表连接，依次是从最好的到最差的：

system:表只有一行记录（等于系统表）。这是 const表连接类型的一个特例。

const:表中最多只有一行匹配的记录，它在查询一开始的时候就会被读取出来。由于只有一行记录，在余下的优化程序里该行记录的字段值可以被当作是一个恒定值。const表查询起来非常快，因为只要读取一次！const 用于在和 primary key 或unique 索引中有固定值比较的情形。下面的几个查询中，tbl_name 就是 c表了：
select * from tbl_name where primary_key=1; select * from tbl_namewhere primary_key_part1=1 and primary_key_part2=2;

eq_ref:从该表中会有一行记录被读取出来以和从前一个表中读取出来的记录做联合。与const类型不同的是，这是最好的连接类型。它用在索引所有部分都用于做连接并且这个索引是一个primary key 或 unique 类型。eq_ref可以用于在进行&quot;=&quot;做比较时检索字段。比较的值可以是固定值或者是表达式，表达示中可以使用表里的字段，它们在读表之前已经准备好了。以下的几个例子中，mysql使用了eq_ref 连接来处理 ref_table：


select * from ref_table,other_table whereref_table.key_column=other_table.column; select * fromref_table,other_table whereref_table.key_column_part1=other_table.column andref_table.key_column_part2=1;

ref: 该表中所有符合检索值的记录都会被取出来和从上一个表中取出来的记录作联合。ref用于连接程序使用键的最左前缀或者是该键不是 primary key 或 unique索引（换句话说，就是连接程序无法根据键值只取得一条记录）的情况。当根据键值只查询到少数几条匹配的记录时，这就是一个不错的连接类型。 ref还可以用于检索字段使用 =操作符来比较的时候。以下的几个例子中，mysql将使用 ref 来处理ref_table：
select * from ref_table where key_column=expr; select * fromref_table,other_table whereref_table.key_column=other_table.column; select * fromref_table,other_table whereref_table.key_column_part1=other_table.column andref_table.key_column_part2=1;

ref_or_null: 这种连接类型类似 ref，不同的是mysql会在检索的时候额外的搜索包含null 值的记录。这种连接类型的优化是从mysql4.1.1开始的，它经常用于子查询。在以下的例子中，mysql使用ref_or_null 类型来处理 ref_table：
select * from ref_table where key_column=expr or key_column is null;


unique_subquery: 这种类型用例如一下形式的 in 子查询来替换 ref：
value in (select primary_key from single_table where some_expr)

unique_subquery: 只是用来完全替换子查询的索引查找函数效率更高了。

index_subquery: 这种连接类型类似 unique_subquery。它用子查询来代替in，不过它用于在子查询中没有唯一索引的情况下，例如以下形式：
value in (select key_column from single_table where some_expr)

range: 只有在给定范围的记录才会被取出来，利用索引来取得一条记录。key字段表示使用了哪个索引。key_len字段包括了使用的键的最长部分。这种类型时 ref 字段值是 null。range用于将某个字段和一个定植用以下任何操作符比较时 =, &amp;lt;&amp;gt;, &amp;gt;,&amp;gt;=, &amp;lt;, &amp;lt;=, is null, &amp;lt;=&amp;gt;, between, 或 in：
select * from tbl_name where key_column = 10; select * fromtbl_name where key_column between 10 and 20; select * from tbl_namewhere key_column in (10,20,30); select * from tbl_name wherekey_part1= 10 and key_part2 in (10,20,30);

index: 连接类型跟 all 一样，不同的是它只扫描索引树。它通常会比 all快点，因为索引文件通常比数据文件小。mysql在查询的字段知识单独的索引的一部分的情况下使用这种连接类型。

all: 将对该表做全部扫描以和从前一个表中取得的记录作联合。这时候如果第一个表没有被标识为const的话就不大好了，在其他情况下通常是非常糟糕的。正常地，可以通过增加索引使得能从表中更快的取得记录以避免all。

possible_keys

possible_keys字段是指 mysql在搜索表记录时可能使用哪个索引。注意，这个字段完全独立于explain 显示的表顺序。这就意味着 possible_keys里面所包含的索引可能在实际的使用中没用到。如果这个字段的值是null，就表示没有索引被用到。这种情况下，就可以检查 where子句中哪些字段那些字段适合增加索引以提高查询的性能。就这样，创建一下索引，然后再用explain 检查一下。详细的查看章节&quot;14.2.2 alter tablesyntax&quot;。想看表都有什么索引，可以通过 show index from tbl_name来看。

key

key字段显示了mysql实际上要用的索引。当没有任何索引被用到的时候，这个字段的值就是null。想要让mysql强行使用或者忽略在 possible_keys字段中的索引列表，可以在查询语句中使用关键字force index, use index,或 ignore index。如果是 myisam 和 bdb 类型表，可以使用 analyzetable 来帮助分析使用使用哪个索引更好。如果是 myisam类型表，运行命令 myisamchk --analyze也是一样的效果。详细的可以查看章节&quot;14.5.2.1 analyze tablesyntax&quot;和&quot;5.7.2 table maintenance and crash recovery&quot;。

key_len

key_len 字段显示了mysql使用索引的长度。当 key 字段的值为 null时，索引的长度就是 null。注意，key_len的值可以告诉你在联合索引中mysql会真正使用了哪些索引。

ref

ref 字段显示了哪些字段或者常量被用来和 key配合从表中查询记录出来。

rows
rows 字段显示了mysql认为在查询中应该检索的记录数。

extra

本字段显示了查询中mysql的附加信息。以下是这个字段的几个不同值的解释：

distinct:mysql当找到当前记录的匹配联合结果的第一条记录之后，就不再搜索其他记录了。

not exists:mysql在查询时做一个 left join优化时，当它在当前表中找到了和前一条记录符合 left join条件后，就不再搜索更多的记录了。下面是一个这种类型的查询例子：
select * from t1 left join t2 on t1.id=t2.id where t2.id isnull;

假使 t2.id 定义为 not null。这种情况下，mysql将会扫描表 t1并且用 t1.id 的值在 t2 中查找记录。当在 t2中找到一条匹配的记录时，这就意味着 t2.id 肯定不会都是null，就不会再在 t2 中查找相同 id值的其他记录了。也可以这么说，对于 t1 中的每个记录，mysql只需要在t2 中做一次查找，而不管在 t2 中实际有多少匹配的记录。

range checked for each record (index map: #)

mysql没找到合适的可用的索引。取代的办法是，对于前一个表的每一个行连接，它会做一个检验以决定该使用哪个索引（如果有的话），并且使用这个索引来从表里取得记录。这个过程不会很快，但总比没有任何索引时做表连接来得快。

using filesort: mysql需要额外的做一遍从而以排好的顺序取得记录。排序程序根据连接的类型遍历所有的记录，并且将所有符合 where条件的记录的要排序的键和指向记录的指针存储起来。这些键已经排完序了，对应的记录也会按照排好的顺序取出来。详情请看&quot;7.2.9how mysql optimizes order by&quot;。
using index

字段的信息直接从索引树中的信息取得，而不再去扫描实际的记录。这种策略用于查询时的字段是一个独立索引的一部分。

using temporary: mysql需要创建临时表存储结果以完成查询。这种情况通常发生在查询时包含了groupby 和 order by 子句，它以不同的方式列出了各个字段。
using where

where子句将用来限制哪些记录匹配了下一个表或者发送给客户端。除非你特别地想要取得或者检查表种的所有记录，否则的话当查询的extra 字段值不是 using where 并且表连接类型是 all 或 index时可能表示有问题。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果你想要让查询尽可能的快，那么就应该注意 extra 字段的值为usingfilesort 和 using temporary 的情况。&lt;/p&gt;

&lt;p&gt;你可以通过 explain 的结果中 rows字段的值的乘积大概地知道本次连接表现如何。它可以粗略地告诉我们mysql在查询过程中会查询多少条记录。如果是使用系统变量 max_join_size 来取得查询结果，这个乘积还可以用来确定会执行哪些多表select 语句。
下面的例子展示了如何通过 explain提供的信息来较大程度地优化多表联合查询的性能。
假设有下面的 select 语句，正打算用 explain 来检测：
explain select tt.ticketnumber, tt.timein, tt.projectreference,tt.estimatedshipdate, tt.actualshipdate, tt.clientid,tt.servicecodes, tt.repetitiveid, tt.currentprocess,tt.currentdppers tt.recordvolume, tt.dpprinted, et.country,et_1.country, do.custname from tt, et, et as et_1, do wherett.submittime is null and tt.actualpc = et.employid andtt.assignedpc = et_1.employid and tt.clientid = do.custnmbr;&lt;/p&gt;

&lt;p&gt;在这个例子中，先做以下假设：&lt;/p&gt;

&lt;p&gt;要比较的字段定义如下：
    table  column  columntype
    tt  actualpc char(10)
    tt  assignedpc char(10)
    tt  clientid char(10)
    et  employid char(15)
    do  custnmbr char(15)&lt;/p&gt;

&lt;p&gt;数据表的索引如下：
    table  index
    tt  actualpc
    tt  assignedpc
    tt  clientid
    et  employid (primary key)
    do  custnmbr (primary key)&lt;/p&gt;

&lt;p&gt;tt.actualpc 的值是不均匀分布的。&lt;/p&gt;

&lt;p&gt;在任何优化措施未采取之前，经过 explain分析的结果显示如下：
    table type possible_keys key key_len ref rows extra
    et all primarynull null null 74
    do all primary null null null 2135
    et_1 allprimary null null null 74
    tt all assignedpc, null null null 3872 clientid, actualpc range checked for each record (key map: 35)&lt;/p&gt;

&lt;p&gt;由于字段 type 的对于每个表值都是all，这个结果意味着mysql对所有的表做一个迪卡尔积；这就是说，每条记录的组合。这将需要花很长的时间，因为需要扫描每个表总记录数乘积的总和。在这情况下，它的积是74 * 2135 * 74 * 3872 = 45,268,558,720条记录。如果数据表更大的话，你可以想象一下需要多长的时间。
在这里有个问题是当字段定义一样的时候，mysql就可以在这些字段上更快的是用索引（对isam类型的表来说，除非字段定义完全一样，否则不会使用索引）。在这个前提下，varchar和 char是一样的除非它们定义的长度不一致。由于 tt.actualpc 定义为char(10)，et.employid 定义为 char(15)，二者长度不一致。
为了解决这个问题，需要用 alter table 来加大 actualpc的长度从10到15个字符：
mysql&amp;gt; alter table tt modify actualpc varchar(15);&lt;/p&gt;

&lt;p&gt;现在 tt.actualpc 和 et.employid 都是 varchar(15)了。再来执行一次 explain 语句看看结果：
    table type possible_keys key key_len ref rows extra
    tt allassignedpc, null null null 3872 using clientid, where actualpc
    do all primary null null null 2135 range checked for each record (keymap: 1)
    et_1 all primary null null null 74 range checked for eachrecord (key map: 1) et eq_ref primary primary 15 tt.actualpc 1&lt;/p&gt;

&lt;p&gt;这还不够，它还可以做的更好：现在 rows值乘积已经少了74倍。这次查询需要用2秒钟。
第二个改变是消除在比较 tt.assignedpc = et_1.employid 和 tt.clientid= do.custnmbr 中字段的长度不一致问题：
mysql&amp;gt; alter table tt modify assignedpc varchar(15), -&amp;gt;modify clientid varchar(15);&lt;/p&gt;

&lt;p&gt;现在 explain 的结果如下：
table type possible_keys key key_len ref rows extra
et all primary null null null 74
tt ref assignedpc, actualpc 15 et.employid 52 using clientid, where actualpc
et_1 eq_ref primary primary 15 tt.assignedpc 1
do eq_ref primary primary 15 tt.clientid 1&lt;/p&gt;

&lt;p&gt;这看起来已经是能做的最好的结果了。
遗留下来的问题是，mysql默认地认为字段 tt.actualpc的值是均匀分布的，然而表 tt并非如此。幸好，我们可以很方便的让mysql分析索引的分布：
mysql&amp;gt; analyze table tt;&lt;/p&gt;

&lt;p&gt;到此为止，表连接已经优化的很完美了，explain 的结果如下：
table type possible_keys key key_len ref rows extra
tt all assignedpc null null null 3872 using clientid, where actualpc
et eq_ref primary primary 15 tt.actualpc 1
et_1 eq_ref primary primary 15 tt.assignedpc 1
do eq_ref primary primary 15 tt.clientid 1&lt;/p&gt;

&lt;p&gt;请注意，explain 结果中的 rows字段的值也是mysql的连接优化程序大致猜测的，请检查这个值跟真实值是否基本一致。如果不是，可以通过在select 语句中使用 straight_join 来取得更好的性能，同时可以试着在from分句中用不同的次序列出各个表。&lt;/p&gt;

&lt;p&gt;以下为补充资料：&lt;/p&gt;

&lt;p&gt;借助explain，可以知道：
1)何时必须为表加入索引以得到一个使用索引找到记录的更快的SELECT。
2)优化器是否以一个最佳次序联结表。为了强制优化器对一个SELECT语句使用一个特定联结次序，增加一个STRAIGHT_JOIN子句。
官方的关于explain的文档在http://dev.mysql.com/doc/refman/5.1/en/using-explain.html（英文）&lt;/p&gt;

&lt;p&gt;mysql explain详解&lt;/p&gt;

&lt;p&gt;mysql explain 使用的方法&lt;/p&gt;

&lt;p&gt;EXPLAIN tbl_name
或：
EXPLAIN [EXTENDED] SELECT select_options&lt;/p&gt;

&lt;p&gt;前者可以得出一个表的字段结构等等，后者主要是给出相关的一些索引信息，而今天要讲述的重点是后者。&lt;/p&gt;

&lt;p&gt;举例
复制代码 代码如下:&lt;/p&gt;

&lt;p&gt;mysql&amp;gt; explain select * from event;&lt;/p&gt;

&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;select_type&lt;/th&gt;
      &lt;th&gt;table&lt;/th&gt;
      &lt;th&gt;type&lt;/th&gt;
      &lt;th&gt;possible_keys&lt;/th&gt;
      &lt;th&gt;key&lt;/th&gt;
      &lt;th&gt;key_len&lt;/th&gt;
      &lt;th&gt;ref&lt;/th&gt;
      &lt;th&gt;rows&lt;/th&gt;
      &lt;th&gt;Extra&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;SIMPLE&lt;/td&gt;
      &lt;td&gt;event&lt;/td&gt;
      &lt;td&gt;ALL&lt;/td&gt;
      &lt;td&gt;NULL&lt;/td&gt;
      &lt;td&gt;NULL&lt;/td&gt;
      &lt;td&gt;NULL&lt;/td&gt;
      &lt;td&gt;NULL&lt;/td&gt;
      &lt;td&gt;13&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;
&lt;p&gt;1 row in set (0.00 sec)&lt;/p&gt;

&lt;p&gt;各个属性的含义&lt;/p&gt;

&lt;p&gt;id
select查询的序列号&lt;/p&gt;

&lt;p&gt;select_type
select查询的类型，主要是区别普通查询和联合查询、子查询之类的复杂查询。&lt;/p&gt;

&lt;p&gt;table
输出的行所引用的表。&lt;/p&gt;

&lt;p&gt;type
联合查询所使用的类型。
type显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：
system &amp;gt; const &amp;gt; eq_ref &amp;gt; ref &amp;gt; fulltext &amp;gt; ref_or_null &amp;gt; index_merge &amp;gt; unique_subquery &amp;gt; index_subquery &amp;gt; range &amp;gt; index &amp;gt; ALL
一般来说，得保证查询至少达到range级别，最好能达到ref。&lt;/p&gt;

&lt;p&gt;possible_keys
指出MySQL能使用哪个索引在该表中找到行。如果是空的，没有相关的索引。这时要提高性能，可通过检验WHERE子句，看是否引用某些字段，或者检查字段不是适合索引。&lt;/p&gt;

&lt;p&gt;key
显示MySQL实际决定使用的键。如果没有索引被选择，键是NULL。&lt;/p&gt;

&lt;p&gt;key_len
显示MySQL决定使用的键长度。如果键是NULL，长度就是NULL。文档提示特别注意这个值可以得出一个多重主键里mysql实际使用了哪一部分。&lt;/p&gt;

&lt;p&gt;ref
显示哪个字段或常数与key一起被使用。&lt;/p&gt;

&lt;p&gt;rows
这个数表示mysql要遍历多少数据才能找到，在innodb上是不准确的。&lt;/p&gt;

&lt;p&gt;Extra
如果是Only index，这意味着信息只用索引树中的信息检索出的，这比扫描整个表要快。
如果是where used，就是使用上了where限制。
如果是impossible where 表示用不着where，一般就是没查出来啥。
如果此信息显示Using filesort或者Using temporary的话会很吃力，WHERE和ORDER BY的索引经常无法兼顾，如果按照WHERE来确定索引，那么在ORDER BY时，就必然会引起Using filesort，这就要看是先过滤再排序划算，还是先排序再过滤划算。
常见的一些名词解释&lt;/p&gt;

&lt;p&gt;Using filesort
MySQL需要额外的一次传递，以找出如何按排序顺序检索行。&lt;/p&gt;

&lt;p&gt;Using index
从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。&lt;/p&gt;

&lt;p&gt;Using temporary
为了解决查询，MySQL需要创建一个临时表来容纳结果。&lt;/p&gt;

&lt;p&gt;ref
对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取&lt;/p&gt;

&lt;p&gt;ALL
完全没有索引的情况，性能非常地差劲。&lt;/p&gt;

&lt;p&gt;index
与ALL相同，除了只有索引树被扫描。这通常比ALL快，因为索引文件通常比数据文件小。&lt;/p&gt;

&lt;p&gt;SIMPLE
简单SELECT(不使用UNION或子查询)&lt;/p&gt;
</description>
        <pubDate>Thu, 17 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://amazingw.github.com/2016/03/17/sql-use-of-explain.html</link>
        <guid isPermaLink="true">http://amazingw.github.com/2016/03/17/sql-use-of-explain.html</guid>
        
        <category>sql</category>
        
        <category>优化</category>
        
        <category>设计</category>
        
        <category>explain</category>
        
        
        <category>服务端开发</category>
        
      </item>
    
      <item>
        <title>优化之查询语句优化</title>
        <description>&lt;p&gt;mysql的性能优化包罗甚广：
索引优化，查询优化，查询缓存，服务器设置优化，操作系统和硬件优化，应用层面优化（web服务器，缓存）等等。这里的记录的优化技巧更适用于开发人员，都是从网络上收集和自己整理的，主要是查询语句上面的优化，其它层面的优化技巧在此不做记录。&lt;/p&gt;

&lt;p&gt;查询的开销指标：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;执行时间
检查的行数
返回的行数
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;建立索引的几个准则：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1、合理的建立索引能够加速数据读取效率，不合理的建立索引反而会拖慢数据库的响应速度。
2、索引越多，更新数据的速度越慢。
3、尽量在采用MyIsam作为引擎的时候使用索引（因为MySQL以BTree存储索引），而不是InnoDB。但MyISAM不支持Transcation。
4、当你的程序和数据库结构/SQL语句已经优化到无法优化的程度，而程序瓶颈并不能顺利解决，那就是应该考虑使用诸如memcached这样的分布式缓存系统的时候了。
5、习惯和强迫自己用EXPLAIN来分析你SQL语句的性能。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;count&quot;&gt;1. count的优化&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;比如：计算id大于5的城市
a. select count(*) from world.city where id &amp;gt; 5;
b. select (select count(*) from world.city) – count(*) from world.city where id &amp;lt;= 5;
a语句当行数超过11行的时候需要扫描的行数比b语句要多， b语句扫描了6行，此种情况下，b语句比a语句更有效率。当没有where语句的时候直接select count(*) from world.city这样会更快，因为mysql总是知道表的行数。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section&quot;&gt;2. 避免使用不兼容的数据类型。&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;例如float和int、char和varchar、binary和varbinary是不兼容的。数据类型的不兼容可能使优化器无法执行一些本来可以进行的优化操作。
在程序中，保证在实现功能的基础上，尽量减少对数据库的访问次数；通过搜索参数，尽量减少对表的访问行数,最小化结果集，从而减轻网络负担；能够分开的操作尽量分开处理，提高每次的响应速度；在数据窗口使用SQL时，尽量把使用的索引放在选择的首列；算法的结构尽量简单；在查询时，不要过多地使用通配符如 SELECT * FROM T1语句，要用到几列就选择几列如：SELECT COL1,COL2 FROM T1；在可能的情况下尽量限制尽量结果集行数如：SELECT TOP 300 COL1,COL2,COL3 FROM T1,因为某些情况下用户是不需要那么多的数据的。不要在应用中使用数据库游标，游标是非常有用的工具，但比使用常规的、面向集的SQL语句需要更大的开销；按照特定顺序提取数据的查找。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-1&quot;&gt;3. 索引字段上进行运算会使索引失效。&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;尽量避免在WHERE子句中对字段进行函数或表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：

SELECT * FROM T1 WHERE F1/2=100 应改为: SELECT * FROM T1 WHERE F1=100*2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;is-nullis-not-nullin-not-in&quot;&gt;4. 避免使用!=或＜＞、IS NULL或IS NOT NULL、IN ，NOT IN等这样的操作符.&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;因为这会使系统无法使用索引,而只能直接搜索表中的数据。例如: SELECT id FROM employee WHERE id != “B%” 优化器将无法通过索引来确定将要命中的行数,因此需要搜索该表的所有行。在in语句中能用exists语句代替的就用exists.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;5. 尽量使用数字型字段.&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;一部分开发人员和数据库管理人员喜欢把包含数值信息的字段
设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接回逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;existsnot-exists&quot;&gt;6. 合理使用EXISTS,NOT EXISTS子句。如下所示：&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.SELECT SUM(T1.C1) FROM T1 WHERE (SELECT COUNT(*)FROM T2 WHERE T2.C2=T1.C2&amp;gt;0)
2.SELECT SUM(T1.C1) FROM T1WHERE EXISTS(SELECT * FROM T2 WHERE T2.C2=T1.C2)

两者产生相同的结果，但是后者的效率显然要高于前者。因为后者不会产生大量锁定的表扫描或是索引扫描。如果你想校验表里是否存在某条纪录，不要用count(*)那样效率很低，而且浪费服务器资源。可以用EXISTS代替。如：

IF (SELECT COUNT(*) FROM table_name WHERE column_name = ‘xxx’)可以写成：IF EXISTS (SELECT * FROM table_name WHERE column_name = ‘xxx’)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;betweenin&quot;&gt;7. 能够用BETWEEN的就不要用IN&lt;/h4&gt;

&lt;h4 id=&quot;distinctgroup-by&quot;&gt;8. 能够用DISTINCT的就不用GROUP BY&lt;/h4&gt;

&lt;h4 id=&quot;select-intoselect-into-&quot;&gt;9. 尽量不要用SELECT INTO语句。SELECT INTO 语句会导致表锁定，阻止其他用户访问该表。&lt;/h4&gt;

&lt;h4 id=&quot;section-3&quot;&gt;10. 必要时强制查询优化器使用某个索引&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM T1 WHERE nextprocess = 1 AND processid IN (8,32,45) 改成：
SELECT * FROM T1 (INDEX = IX_ProcessID) WHERE nextprocess = 1 AND processid IN (8,32,45)
则查询优化器将会强行利用索引IX_ProcessID 执行查询。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-4&quot;&gt;11. 消除对大型表行数据的顺序存取&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;尽管在所有的检查列上都有索引，但某些形式的WHERE子句强迫优化器使用顺序存取。如：
SELECT * FROM orders WHERE (customer_num=104 AND order_num&amp;gt;1001) OR order_num=1008
解决办法可以使用并集来避免顺序存取：
SELECT * FROM orders WHERE customer_num=104 AND order_num&amp;gt;1001 UNION SELECT * FROM orders WHERE order_num=1008
这样就能利用索引路径处理查询。【jacking 数据结果集很多，但查询条件限定后结果集不大的情况下，后面的语句快】
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-5&quot;&gt;12. 尽量避免在索引过的字符数据中，使用非打头字母搜索。这也使得引擎无法利用索引。&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;见如下例子：
SELECT * FROM T1 WHERE NAME LIKE ‘%L%’
SELECT * FROM T1 WHERE SUBSTING(NAME,2,1)=’L’
SELECT * FROM T1 WHERE NAME LIKE ‘L%’
即使NAME字段建有索引，前两个查询依然无法利用索引完成加快操作，引擎不得不对全表所有数据逐条操作来完成任务。而第三个查询能够使用索引来加快操作，不要习惯性的使用 ‘%L%’这种方式(会导致全表扫描)，如果可以使用`L%’相对来说更好;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;updatedeleteupdate&quot;&gt;13. 虽然UPDATE、DELETE语句的写法基本固定，但是还是对UPDATE语句给点建议：&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a) 尽量不要修改主键字段。

b) 当修改VARCHAR型字段时，尽量使用相同长度内容的值代替。

c) 尽量最小化对于含有UPDATE触发器的表的UPDATE操作。

d) 避免UPDATE将要复制到其他数据库的列。

e) 避免UPDATE建有很多索引的列。

f) 避免UPDATE在WHERE子句条件中的列。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;union-allunion&quot;&gt;14. 能用UNION ALL就不要用UNION&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UNION ALL不执行SELECT DISTINCT函数，这样就会减少很多不必要的资源

在跨多个不同的数据库时使用UNION是一个有趣的优化方法，UNION从两个互不关联的表中返回数据，这就意味着不会出现重复的行，同时也必须对数据进行排序，我们知道排序是非常耗费资源的，特别是对大表的排序。

UNION ALL可以大大加快速度，如果你已经知道你的数据不会包括重复行，或者你不在乎是否会出现重复的行，在这两种情况下使用UNION ALL更适合。此外，还可以在应用程序逻辑中采用某些方法避免出现重复的行，这样UNION ALL和UNION返回的结果都是一样的，但UNION ALL不会进行排序。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-6&quot;&gt;15. 字段数据类型优化：&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a. 避免使用NULL类型：NULL对于大多数数据库都需要特殊处理，MySQL也不例外，它需要更多的代码，更多的检查和特殊的索引逻辑，有些开发人员完全没有意识到，创建表时NULL是默认值，但大多数时候应该使用NOT NULL，或者使用一个特殊的值，如0，-1作为默认值。

b. 尽可能使用更小的字段，MySQL从磁盘读取数据后是存储到内存中的，然后使用cpu周期和磁盘I/O读取它，这意味着越小的数据类型占用的空间越小，从磁盘读或打包到内存的效率都更好，但也不要太过执着减小数据类型，要是以后应用程序发生什么变化就没有空间了。修改表将需要重构，间接地可能引起代码的改变，这是很头疼的问题，因此需要找到一个平衡点。

c. 优先使用定长型
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;limitlimit&quot;&gt;16. 关于大数据量limit分布的优化见下面链接（当偏移量特别大时，limit效率会非常低）：&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://ariyue.iteye.com/blog/553541

附上一个提高limit效率的简单技巧，在覆盖索引(覆盖索引用通俗的话讲就是在select的时候只用去读取索引而取得数据，无需进行二次select相关表)上进行偏移，而不是对全行数据进行偏移。可以将从覆盖索引上提取出来的数据和全行数据进行联接，然后取得需要的列，会更有效率，看看下面的查询：

mysql&amp;gt; select film_id, description from sakila.film order by title limit 50, 5;

如果表非常大，这个查询最好写成下面的样子：

mysql&amp;gt; select film.film_id, film.description from sakila.film

inner join(select film_id from sakila.film order by title liimit 50,5) as film usinig(film_id);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-7&quot;&gt;17. 程序中如果一次性对同一个表插入多条数据，比如以下语句：&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;insert into person(name,age) values(‘xboy’, 14);

insert into person(name,age) values(‘xgirl’, 15);

insert into person(name,age) values(‘nia’, 19);

把它拼成一条语句执行效率会更高.

insert into person(name,age) values(‘xboy’, 14), (‘xgirl’, 15),(‘nia’, 19);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;whereorder-by&quot;&gt;18. 不要在选择的栏位上放置索引，这是无意义的。应该在条件选择的语句上合理的放置索引，比如where，order by。&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT id,title,content,cat_id FROM article WHERE cat_id = 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面这个语句，你在id/title/content上放置索引是毫无意义的，对这个语句没有任何优化作用。但是如果你在外键cat_id上放置一个索引，那作用就相当大了。&lt;/p&gt;

&lt;h4 id=&quot;order-bymysql&quot;&gt;19. ORDER BY语句的MySQL优化：&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a. ORDER BY + LIMIT组合的索引优化。如果一个SQL语句形如：

SELECT [column1],[column2],…. FROM [TABLE] ORDER BY [sort] LIMIT [offset],[LIMIT];

这个SQL语句优化比较简单，在[sort]这个栏位上建立索引即可。

b. WHERE + ORDER BY + LIMIT组合的索引优化，形如：

SELECT [column1],[column2],…. FROM [TABLE] WHERE [columnX] = [VALUE] ORDER BY [sort] LIMIT [offset],[LIMIT];

这个语句，如果你仍然采用第一个例子中建立索引的方法，虽然可以用到索引，但是效率不高。更高效的方法是建立一个联合索引(columnX,sort)

c. WHERE + IN + ORDER BY + LIMIT组合的索引优化，形如：

SELECT [column1],[column2],…. FROM [TABLE] WHERE [columnX] IN ([value1],[value2],…) ORDER BY [sort] LIMIT [offset],[LIMIT];

这个语句如果你采用第二个例子中建立索引的方法，会得不到预期的效果（仅在[sort]上是using index，WHERE那里是using where;using filesort），理由是这里对应columnX的值对应多个。
目前哥还木有找到比较优秀的办法，等待高手指教。

d.WHERE+ORDER BY多个栏位+LIMIT，比如:

SELECT * FROM [table] WHERE uid=1 ORDER x,y LIMIT 0,10;

对于这个语句，大家可能是加一个这样的索引:(x,y,uid)。但实际上更好的效果是(uid,x,y)。这是由MySQL处理排序的机制造成的。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-8&quot;&gt;20. 其它技巧：&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://www.cnblogs.com/nokiaguy/archive/2008/05/24/1206469.html
http://www.cnblogs.com/suchshow/archive/2011/12/15/2289182.html
http://www.cnblogs.com/cy163/archive/2009/05/28/1491473.html
http://www.cnblogs.com/younggun/articles/1719943.html
http://wenku.baidu.com/view/f57c7041be1e650e52ea9985.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后，你可以使用explain关键字去判断和评测一个sql语句是否还有优化的可能性，关于它的详细使用请参考mysql手册。&lt;/p&gt;
</description>
        <pubDate>Thu, 17 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://amazingw.github.com/2016/03/17/sql-design.html</link>
        <guid isPermaLink="true">http://amazingw.github.com/2016/03/17/sql-design.html</guid>
        
        <category>sql</category>
        
        <category>优化</category>
        
        <category>设计</category>
        
        
        <category>服务端开发</category>
        
      </item>
    
      <item>
        <title>coc服务器设计图</title>
        <description>&lt;p&gt;&lt;img src=&quot;../../../assets/img/server_design.png&quot; alt=&quot;服务器设计图&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 17 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://amazingw.github.com/2016/03/17/server-design.html</link>
        <guid isPermaLink="true">http://amazingw.github.com/2016/03/17/server-design.html</guid>
        
        <category>设计</category>
        
        <category>开发</category>
        
        <category>服务端</category>
        
        
        <category>服务端开发</category>
        
      </item>
    
      <item>
        <title>nodejs守护进程的启动方法</title>
        <description>&lt;p&gt;“守护进程”（daemon）就是一直在后台运行的进程（daemon）。&lt;/p&gt;

&lt;p&gt;本文介绍如何将一个 Web 应用，启动为守护进程。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;一、问题的由来&lt;/h3&gt;

&lt;p&gt;Web应用写好后，下一件事就是启动，让它一直在后台运行。&lt;/p&gt;

&lt;p&gt;这并不容易。举例来说，下面是一个最简单的Node应用server.js，只有6行。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;http&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;http&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;writeHead&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;Content-Type&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;text/plain&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;Hello World&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;listen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你在命令行下启动它。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;node server.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;看上去一切正常，所有人都能快乐地访问 5000 端口了。但是，一旦你退出命令行窗口，这个应用就一起退出了，无法访问了。&lt;/p&gt;

&lt;p&gt;怎么才能让它变成系统的守护进程（daemon），成为一种服务（service），一直在那里运行呢？
### 二、前台任务与后台任务&lt;/p&gt;

&lt;p&gt;上面这样启动的脚本，称为”前台任务”（foreground job）。它会独占命令行窗口，只有运行完了或者手动中止，才能执行其他命令。&lt;/p&gt;

&lt;p&gt;变成守护进程的第一步，就是把它改成”后台任务”（background job）。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;node server.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;只要在命令的尾部加上符号&amp;amp;，启动的进程就会成为”后台任务”。如果要让正在运行的”前台任务”变为”后台任务”，可以先按ctrl + z，然后执行bg命令（让最近一个暂停的”后台任务”继续执行）。&lt;/p&gt;

&lt;p&gt;“后台任务”有两个特点。&lt;/p&gt;

&lt;p&gt;继承当前 session （对话）的标准输出（stdout）和标准错误（stderr）。因此，后台任务的所有输出依然会同步地在命令行下显示。
  不再继承当前 session 的标准输入（stdin）。你无法向这个任务输入指令了。如果它试图读取标准输入，就会暂停执行（halt）。&lt;/p&gt;

&lt;p&gt;可以看到，”后台任务”与”前台任务”的本质区别只有一个：是否继承标准输入。所以，执行后台任务的同时，用户还可以输入其他命令。&lt;/p&gt;

&lt;h3 id=&quot;sighup&quot;&gt;三、SIGHUP信号&lt;/h3&gt;

&lt;p&gt;变为”后台任务”后，一个进程是否就成为了守护进程呢？或者说，用户退出 session 以后，”后台任务”是否还会继续执行？&lt;/p&gt;

&lt;p&gt;Linux系统是这样设计的。&lt;/p&gt;

&lt;p&gt;用户准备退出 session
  系统向该 session 发出SIGHUP信号
  session 将SIGHUP信号发给所有子进程
  子进程收到SIGHUP信号后，自动退出&lt;/p&gt;

&lt;p&gt;上面的流程解释了，为什么”前台任务”会随着 session 的退出而退出：因为它收到了SIGHUP信号。&lt;/p&gt;

&lt;p&gt;那么，”后台任务”是否也会收到SIGHUP信号？&lt;/p&gt;

&lt;p&gt;这由 Shell 的huponexit参数决定的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;shopt&lt;/span&gt; | grep huponexit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行上面的命令，就会看到huponexit参数的值。&lt;/p&gt;

&lt;p&gt;大多数Linux系统，这个参数默认关闭（off）。因此，session 退出的时候，不会把SIGHUP信号发给”后台任务”。所以，一般来说，”后台任务”不会随着 session 一起退出。
### 四、disown 命令&lt;/p&gt;

&lt;p&gt;通过”后台任务”启动”守护进程”并不保险，因为有的系统的huponexit参数可能是打开的（on）。&lt;/p&gt;

&lt;p&gt;更保险的方法是使用disown命令。它可以将指定任务从”后台任务”列表（jobs命令的返回结果）之中移除。一个”后台任务”只要不在这个列表之中，session 就肯定不会向它发出SIGHUP信号。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;node server.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行上面的命令以后，server.js进程就被移出了”后台任务”列表。你可以执行jobs命令验证，输出结果里面，不会有这个进程。&lt;/p&gt;

&lt;p&gt;disown的用法如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 移出最近一个正在执行的后台任务&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;disown&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 移出所有正在执行的后台任务&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;disown&lt;/span&gt; -r

&lt;span class=&quot;c&quot;&gt;# 移出所有后台任务&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;disown&lt;/span&gt; -a

&lt;span class=&quot;c&quot;&gt;# 不移出后台任务，但是让它们不会收到SIGHUP信号&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;disown&lt;/span&gt; -h

&lt;span class=&quot;c&quot;&gt;# 根据jobId，移出指定的后台任务&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;disown&lt;/span&gt; %2
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;disown&lt;/span&gt; -h %2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;io&quot;&gt;五、标准 I/O&lt;/h3&gt;

&lt;p&gt;使用disown命令之后，还有一个问题。那就是，退出 session 以后，如果后台进程与标准I/O有交互，它还是会挂掉。&lt;/p&gt;

&lt;p&gt;还是以上面的脚本为例，现在加入一行。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;http&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;http&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;server starts...&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 加入此行&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;writeHead&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;Content-Type&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;text/plain&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;Hello World&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;listen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;启动上面的脚本，然后再执行disown命令。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;node server.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接着，你退出 session，访问5000端口，就会发现连不上。&lt;/p&gt;

&lt;p&gt;这是因为”后台任务”的标准 I/O 继承自当前 session，disown命令并没有改变这一点。一旦”后台任务”读写标准 I/O，就会发现它已经不存在了，所以就报错终止执行。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，需要对”后台任务”的标准 I/O 进行重定向。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;node server.js &amp;gt; stdout.txt 2&amp;gt; stderr.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面这样执行，基本上就没有问题了。&lt;/p&gt;

&lt;h3 id=&quot;nohup-&quot;&gt;六、nohup 命令&lt;/h3&gt;

&lt;p&gt;还有比disown更方便的命令，就是nohup。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;nohup node server.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;nohup命令对server.js进程做了三件事。&lt;/p&gt;

&lt;p&gt;阻止SIGHUP信号发到这个进程。
  关闭标准输入。该进程不再能够接收任何输入，即使运行在前台。
  重定向标准输出和标准错误到文件nohup.out。&lt;/p&gt;

&lt;p&gt;也就是说，nohup命令实际上将子进程与它所在的 session 分离了。&lt;/p&gt;

&lt;p&gt;注意，nohup命令不会自动把进程变为”后台任务”，所以必须加上&amp;amp;符号。&lt;/p&gt;

&lt;h3 id=&quot;screen--tmux-&quot;&gt;七、Screen 命令与 Tmux 命令&lt;/h3&gt;

&lt;p&gt;另一种思路是使用 terminal multiplexer （终端复用器：在同一个终端里面，管理多个session），典型的就是 Screen 命令和 Tmux 命令。&lt;/p&gt;

&lt;p&gt;它们可以在当前 session 里面，新建另一个 session。这样的话，当前 session 一旦结束，不影响其他 session。而且，以后重新登录，还可以再连上早先新建的 session。&lt;/p&gt;

&lt;p&gt;Screen 的用法如下。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 新建一个 session&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;screen
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;node server.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;然后，按下ctrl + A和ctrl + D，回到原来的 session，从那里退出登录。下次登录时，再切回去。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;screen -r
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果新建多个后台 session，就需要为它们指定名字。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;screen -S name

&lt;span class=&quot;c&quot;&gt;# 切回指定 session&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;screen -r name
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;screen -r pid_number

&lt;span class=&quot;c&quot;&gt;# 列出所有 session&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;screen -ls
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果要停掉某个 session，可以先切回它，然后按下ctrl + c和ctrl + d。&lt;/p&gt;

&lt;p&gt;Tmux 比 Screen 功能更多、更强大，它的基本用法如下。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;tmux
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;node server.js

&lt;span class=&quot;c&quot;&gt;# 返回原来的session&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;tmux detach
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;除了tmux detach，另一种方法是按下Ctrl + B和d ，也可以回到原来的 session。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 下次登录时，返回后台正在运行服务session&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;tmux attach
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果新建多个 session，就需要为每个 session 指定名字。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 新建 session&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;tmux new -s session_name

&lt;span class=&quot;c&quot;&gt;# 切换到指定 session&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;tmux attach -t session_name

&lt;span class=&quot;c&quot;&gt;# 列出所有 session&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;tmux list-sessions

&lt;span class=&quot;c&quot;&gt;# 退出当前 session，返回前一个 session&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;tmux detach

&lt;span class=&quot;c&quot;&gt;# 杀死指定 session&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;tmux &lt;span class=&quot;nb&quot;&gt;kill&lt;/span&gt;-session -t session-name
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;node-&quot;&gt;八、Node 工具&lt;/h3&gt;

&lt;p&gt;对于 Node 应用来说，可以不用上面的方法，有一些专门用来启动的工具：forever，nodemon 和 pm2。&lt;/p&gt;

&lt;p&gt;forever 的功能很简单，就是保证进程退出时，应用会自动重启。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 作为前台任务启动&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;forever server.js

&lt;span class=&quot;c&quot;&gt;# 作为服务进程启动&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;forever start app.js

&lt;span class=&quot;c&quot;&gt;# 停止服务进程&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;forever stop Id

&lt;span class=&quot;c&quot;&gt;# 重启服务进程&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;forever restart Id

&lt;span class=&quot;c&quot;&gt;# 监视当前目录的文件变动，一有变动就重启&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;forever -w server.js

&lt;span class=&quot;c&quot;&gt;# -m 参数指定最多重启次数&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;forever -m 5 server.js

&lt;span class=&quot;c&quot;&gt;# 列出所有进程&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;forever list
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;nodemon一般只在开发时使用，它最大的长处在于 watch 功能，一旦文件发生变化，就自动重启进程。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 默认监视当前目录的文件变化&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;nodemon server.js

＃ 监视指定文件的变化
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;nodemon --watch app --watch libs server.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;pm2 的功能最强大，除了重启进程以外，还能实时收集日志和监控。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 启动应用&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;pm2 start app.js

&lt;span class=&quot;c&quot;&gt;# 指定同时起多少个进程（由CPU核心数决定），组成一个集群&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;pm2 start app.js -i max

&lt;span class=&quot;c&quot;&gt;# 列出所有任务&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;pm2 list

&lt;span class=&quot;c&quot;&gt;# 停止指定任务&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;pm2 stop 0

＃ 重启指定任务
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;pm2 restart 0

&lt;span class=&quot;c&quot;&gt;# 删除指定任务&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;pm2 delete 0

&lt;span class=&quot;c&quot;&gt;# 保存当前的所有任务，以后可以恢复&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;pm2 save

&lt;span class=&quot;c&quot;&gt;# 列出每个进程的统计数据&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;pm2 monit

&lt;span class=&quot;c&quot;&gt;# 查看所有日志&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;pm2 logs

&lt;span class=&quot;c&quot;&gt;# 导出数据&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;pm2 dump

&lt;span class=&quot;c&quot;&gt;# 重启所有进程&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;pm2 &lt;span class=&quot;nb&quot;&gt;kill&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;pm2 resurect

&lt;span class=&quot;c&quot;&gt;# 启动web界面 http://localhost:9615&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;pm2 web
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;systemd&quot;&gt;九、Systemd&lt;/h3&gt;

&lt;p&gt;除了专用工具以外，Linux系统有自己的守护进程管理工具 Systemd 。它是操作系统的一部分，直接与内核交互，性能出色，功能极其强大。我们完全可以将程序交给 Systemd ，让系统统一管理，成为真正意义上的系统服务&lt;/p&gt;
</description>
        <pubDate>Thu, 17 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://amazingw.github.com/2016/03/17/nodejs-deamon-fork.html</link>
        <guid isPermaLink="true">http://amazingw.github.com/2016/03/17/nodejs-deamon-fork.html</guid>
        
        <category>nodejs</category>
        
        <category>server</category>
        
        <category>develop</category>
        
        
        <category>服务端开发</category>
        
      </item>
    
      <item>
        <title>Linux文件格式详解</title>
        <description>&lt;p&gt;本文讨论了 UNIX/LINUX平台下三种主要的可执行文件格式：a.out（assembler and link editor output汇编器和链接编辑器的输出）、COFF（Common Object File Format 通用对象文件格式）、ELF（Executableand Linking Format 可执行和链接格式）。首先是对可执行文件格式的一个综述，并通过描述 ELF文件加载过程以揭示可执行文件内容与加载运行操作之间的关系。随后依此讨论了此三种文件格式，并着重讨论 ELF文件的动态连接机制，其间也穿插了对各种文件格式优缺点的评价。最后对三种可执行文件格式有一个简单总结，并提出作者对可文件格式评价的一些感想。&lt;/p&gt;

&lt;p&gt;可执行文件格式综述
相对于其它文件类型，可执行文件可能是一个操作系统中最重要的文件类型，因为它们是完成操作的真正执行者。可执行文件的大小、运行速度、资源占用情况以及可扩展性、可移植性等与文件格式的定义和文件加载过程紧密相关。研究可执行文件的格式对编写高性能程序和一些黑客技术的运用都是非常有意义的。&lt;/p&gt;

&lt;p&gt;不 管何种可执行文件格式，一些基本的要素是必须的，显而易见的，文件中应包含代码和数据。因为文件可能引用外部文件定义的符号（变量和函数），因此重定位信 息和符号信息也是需要的。一些辅助信息是可选的，如调试信息、硬件信息等。基本上任意一种可执行文件格式都是按区间保存上述信息，称为段 （Segment）或节（Section）。不同的文件格式中段和节的含义可能有细微区别，但根据上下文关系可以很清楚的理解，这不是关键问题。最后，可 执行文件通常都有一个文件头部以描述本文件的总体结构。&lt;/p&gt;

&lt;p&gt;相对可执 行文件有三个重要的概念：编译（compile）、连接（link，也可称为链接、联接）、加载（load）。源程序文件被编译成目标文件，多个目标文件 被连接成一个最终的可执行文件，可执行文件被加载到内存中运行。因为本文重点是讨论可执行文件格式，因此加载过程也相对重点讨论。下面是LINUX平台下 ELF文件加载过程的一个简单描述。&lt;/p&gt;

&lt;p&gt;1：内核首先读ELF文件的 头部，然后根据头部的数据指示分别读入各种数据结构，找到标记为可加载（loadable）的段，并调用函数 mmap()把段内容加载到内存中。在加载之前，内核把段的标记直接传递给mmap()，段的标记指示该段在内存中是否可读、可写，可执行。显然，文本段 是只读可执行，而数据段是可读可写。这种方式是利用了现代操作系统和处理器对内存的保护功能。著名的Shellcode（参考资料 17）的编写技巧则是突破此保护功能的一个实际例子。&lt;/p&gt;

&lt;p&gt;2：内核分析出ELF文件标记为 PT_INTERP 的段中所对应的动态连接器名称，并加载动态连接器。现代 LINUX 系统的动态连接器通常是 /lib/ld-linux.so.2，相关细节在后面有详细描述。&lt;/p&gt;

&lt;p&gt;3：内核在新进程的堆栈中设置一些标记-值对，以指示动态连接器的相关操作。&lt;/p&gt;

&lt;p&gt;4：内核把控制传递给动态连接器。&lt;/p&gt;

&lt;p&gt;5：动态连接器检查程序对外部文件（共享库）的依赖性，并在需要时对其进行加载。&lt;/p&gt;

&lt;p&gt;6：动态连接器对程序的外部引用进行重定位，通俗的讲，就是告诉程序其引用的外部变量/函数的地址，此地址位于共享库被加载在内存的区间内。动态连接还有一个延迟（Lazy）定位的特性，即只在”真正”需要引用符号时才重定位，这对提高程序运行效率有极大帮助。&lt;/p&gt;

&lt;p&gt;7：动态连接器执行在ELF文件中标记为 .init 的节的代码，进行程序运行的初始化。在早期系统中，初始化代码对应函数 _init(void)(函数名强制固定)，在现代系统中，则对应形式为&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;__attribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;init_function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;……&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中函数名为任意。&lt;/p&gt;

&lt;p&gt;8：动态连接器把控制传递给程序，从 ELF 文件头部中定义的程序进入点开始执行。在 a.out 格式和ELF格式中，程序进入点的值是显式存在的，在 COFF 格式中则是由规范隐含定义。&lt;/p&gt;

&lt;p&gt;从 上面的描述可以看出，加载文件最重要的是完成两件事情：加载程序段和数据段到内存；进行外部定义符号的重定位。重定位是程序连接中一个重要概念。我们知 道，一个可执行程序通常是由一个含有 main()的主程序文件、若干目标文件、若干共享库（Shared Libraries）组成。（注：采用一些特别的技巧，也可编写没有 main函数的程序，请参阅参考资料 2）一个 C程序可能引用共享库定义的变量或函数，换句话说就是程序运行时必须知道这些变量/函数的地址。在静态连接中，程序所有需要使用的外部定义都完全包含在可 执行程序中，而动态连接则只在可执行文件中设置相关外部定义的一些引用信息，真正的重定位是在程序运行之时。静态连接方式有两个大问题：如果库中变量或函 数有任何变化都必须重新编译连接程序；如果多个程序引用同样的变量/函数，则此变量/函数会在文件/内存中出现多次，浪费硬盘/内存空间。比较两种连接方 式生成的可执行文件的大小，可以看出有明显的区别。&lt;/p&gt;

&lt;p&gt;a.out 文件格式分析
a.out 格式在不同的机器平台和不同的 UNIX 操作系统上有轻微的不同，例如在 MC680x0 平台上有 6 个 section。下面我们讨论的是最”标准”的格式。&lt;/p&gt;

&lt;p&gt;a.out 文件包含 7 个 section，格式如下：
exec header（执行头部，也可理解为文件头部）
text segment（文本段）
data segment(数据段)
text relocations(文本重定位段)
data relocations（数据重定位段）
symbol table（符号表）
string table（字符串表）&lt;/p&gt;

&lt;p&gt;执行头部的数据结构：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;a_midmag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* 魔数和其它信息 */&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;a_text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;cm&quot;&gt;/* 文本段的长度 */&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;a_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;cm&quot;&gt;/* 数据段的长度 */&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;a_bss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;       &lt;span class=&quot;cm&quot;&gt;/* BSS段的长度 */&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;a_syms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;cm&quot;&gt;/* 符号表的长度 */&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;a_entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;cm&quot;&gt;/* 程序进入点 */&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;a_trsize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* 文本重定位表的长度 */&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;a_drsize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* 数据重定位表的长度 */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;文 件头部主要描述了各个 section 的长度，比较重要的字段是a_entry（程序进入点），代表了系统在加载程序并初试化各种环境后开始执行程序代码的入口。这个字段在后面讨论的 ELF文件头部中也有出现。由 a.out 格式和头部数据结构我们可以看出，a.out的格式非常紧凑，只包含了程序运行所必须的信息（文本、数据、BSS），而且每个 section的顺序是固定的。这种结构缺乏扩展性，如不能包含”现代”可执行文件中常见的调试信息，最初的 UNIX 黑客对 a.out 文件调试使用的工具是adb，而 adb 是一种机器语言调试器！&lt;/p&gt;

&lt;p&gt;a.out 文件中包含符号表和两个重定位表，这三个表的内容在连接目标文件以生成可执行文件时起作用。在最终可执行的 a.out 文件中，这三个表的长度都为0。a.out文件在连接时就把所有外部定义包含在可执行程序中，如果从程序设计的角度来看，这是一种硬编码方式，或者可称为 模块之间是强藕和的。在后面的讨论中，我们将会具体看到ELF格式和动态连接机制是如何对此进行改进的。&lt;/p&gt;

&lt;p&gt;a.out 是早期UNIX系统使用的可执行文件格式，由 AT&amp;amp;T设计，现在基本上已被 ELF 文件格式代替。a.out 的设计比较简单，但其设计思想明显的被后续的可执行文件格式所继承和发扬。可以参阅参考资料16 和阅读参考资料 15 源代码加深对 a.out 格式的理解。参考资料 12 讨论了如何在”现代”的红帽LINUX运行 a.out格式文件。&lt;/p&gt;

&lt;p&gt;COFF 文件格式分析
COFF 格式比 a.out 格式要复杂一些，最重要的是包含一个节段表(section table)，因此除了 .text，.data，和 .bss 区段以外，还可以包含其它的区段。另外也多了一个可选的头部，不同的操作系统可一对此头部做特定的定义。&lt;/p&gt;

&lt;p&gt;COFF 文件格式如下：
File Header(文件头部)
Optional Header(可选文件头部)
Section 1 Header(节头部)
………
Section n Header(节头部)
Raw Data for Section 1(节数据)
Raw Data for Section n(节数据)
Relocation Info for Sect. 1(节重定位数据)
Relocation Info for Sect. n(节重定位数据)
Line Numbers for Sect. 1(节行号数据)
Line Numbers for Sect. n(节行号数据)
Symbol table(符号表)
String table(字符串表)&lt;/p&gt;

&lt;p&gt;文件头部的数据结构：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filehdr&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;f_magic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* 魔数 */&lt;/span&gt;
       &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;f_nscns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* 节个数 */&lt;/span&gt;
       &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;f_timdat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;cm&quot;&gt;/* 文件建立时间 */&lt;/span&gt;
       &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;f_symptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;cm&quot;&gt;/* 符号表相对文件的偏移量 */&lt;/span&gt;
       &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;f_nsyms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* 符号表条目个数 */&lt;/span&gt;
       &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;f_opthdr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;cm&quot;&gt;/* 可选头部长度 */&lt;/span&gt;
       &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;short&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;f_flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* 标志 */&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;COFF 文件头部中魔数与其它两种格式的意义不太一样，它是表示针对的机器类型，例如 0x014c 相对于 I386 平台，而 0x268 相对于Motorola 68000系列等。当 COFF 文件为可执行文件时，字段 f_flags 的值为F_EXEC（0X00002），同时也表示此文件没有未解析的符号，换句话说，也就是重定位在连接时就已经完成。由此也可以看出，原始的 COFF格式不支持动态连接。为了解决这个问题以及增加一些新的特性，一些操作系统对 COFF 格式进行了扩展。Microsoft 设计了名为PE（Portable Executable）的文件格式，主要扩展是在 COFF 文件头部之上增加了一些专用头部，具体细节请参阅参考资料18，某些 UNIX 系统也对 COFF 格式进行了扩展，如 XCOFF（extended common object fileformat）格式，支持动态连接，请参阅参考资料 5。&lt;/p&gt;

&lt;p&gt;紧接文件头部的是可选头部，COFF 文件格式规范中规定可选头部的长度可以为 0，但在 LINUX 系统下可选头部是必须存在的。下面是 LINUX 下可选头部的数据结构：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;magic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* 魔数 */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;vstamp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* 版本号 */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;tsize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* 文本段长度 */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;dsize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* 已初始化数据段长度 */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;bsize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* 未初始化数据段长度 */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* 程序进入点 */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;text_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;       &lt;span class=&quot;cm&quot;&gt;/* 文本段基地址 */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;data_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;       &lt;span class=&quot;cm&quot;&gt;/* 数据段基地址 */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;COFF_AOUTHDR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;字段 magic 为 0413 时表示 COFF 文件是可执行的，注意到可选头部中显式定义了程序进入点，标准的 COFF 文件没有明确的定义程序进入点的值，通常是从 .text 节开始执行，但这种设计并不好。&lt;/p&gt;

&lt;p&gt;前 面我们提到，COFF 格式比 a.out格式多了一个节段表，一个节头条目描述一个节数据的细节，因此 COFF 格式能包含更多的节，或者说可以根据实际需要，增加特定的节，具体表现在COFF 格式本身的定义以及稍早提及的 COFF 格式扩展。我个人认为，节段表的出现可能是 COFF 格式相对 a.out格式最大的进步。下面我们将简单描述 COFF文件中节的数据结构，因为节的意义更多体现在程序的编译和连接上，所以本文不对其做更多的描述。此外，ELF 格式和COFF格式对节的定义非常相似，在随后的 ELF 格式分析中，我们将省略相关讨论。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;COFF_scnhdr&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;     &lt;span class=&quot;cm&quot;&gt;/* 节名称 */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s_paddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* 物理地址 */&lt;/span&gt;
   &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s_vaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* 虚拟地址 */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;     &lt;span class=&quot;cm&quot;&gt;/* 节长度 */&lt;/span&gt;
   &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s_scnptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* 节数据相对文件的偏移量 */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s_relptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* 节重定位信息偏移量 */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s_lnnoptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* 节行信息偏移量 */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s_nreloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* 节重定位条目数 */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s_nlnno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* 节行信息条目数 */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s_flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* 段标记 */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;有 一点需要注意：LINUX系统中头文件coff.h中对字段s_paddr的注释是”physicaladdress”，但似乎应该理解为”节被加载到内 存中所占用的空间长度”。字段s_flags标记该节的类型，如文本段、数据段、BSS段等。在COFF的节中也出现了行信息，行信息描述了二进制代码与 源代码的行号之间的对映关系，在调试时很有用。&lt;/p&gt;

&lt;p&gt;参考资料 19是一份对COFF格式详细描述的中文资料，更详细的内容请参阅参考资料 20。&lt;/p&gt;

&lt;p&gt;ELF文件格式分析
ELF 文件有三种类型：可重定位文件：也就是通常称的目标文件，后缀为.o。共享文件：也就是通常称的库文件，后缀为.so。可执行文件：本文主要讨论的文件格 式，总的来说，可执行文件的格式与上述两种文件的格式之间的区别主要在于观察的角度不同：一种称为连接视图（Linking View），一种称为执行视图（Execution View）。&lt;/p&gt;

&lt;p&gt;首先看看ELF文件的总体布局：
ELF header(ELF头部)
Program header table(程序头表)
Segment1（段1）
Segment2（段2）
………
Sengmentn（段n）
Setion header table(节头表，可选)&lt;/p&gt;

&lt;p&gt;段 由若干个节(Section)构成,节头表对每一个节的信息有相关描述。对可执行程序而言，节头表是可选的。参考资料 1中作者谈到把节头表的所有数据全部设置为0，程序也能正确运行！ELF头部是一个关于本文件的路线图（roadmap），从总体上描述文件的结构。下面 是ELF头部的数据结构：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e_ident&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EI_NIDENT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;     &lt;span class=&quot;cm&quot;&gt;/* 魔数和相关信息 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Elf32_Half&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;e_type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                 &lt;span class=&quot;cm&quot;&gt;/* 目标文件类型 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Elf32_Half&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;e_machine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;              &lt;span class=&quot;cm&quot;&gt;/* 硬件体系 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Elf32_Word&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;e_version&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;              &lt;span class=&quot;cm&quot;&gt;/* 目标文件版本 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Elf32_Addr&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;e_entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                &lt;span class=&quot;cm&quot;&gt;/* 程序进入点 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Elf32_Off&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;e_phoff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                &lt;span class=&quot;cm&quot;&gt;/* 程序头部偏移量 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Elf32_Off&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;e_shoff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                &lt;span class=&quot;cm&quot;&gt;/* 节头部偏移量 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Elf32_Word&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;e_flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                &lt;span class=&quot;cm&quot;&gt;/* 处理器特定标志 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Elf32_Half&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;e_ehsize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;               &lt;span class=&quot;cm&quot;&gt;/* ELF头部长度 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Elf32_Half&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;e_phentsize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;            &lt;span class=&quot;cm&quot;&gt;/* 程序头部中一个条目的长度 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Elf32_Half&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;e_phnum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                &lt;span class=&quot;cm&quot;&gt;/* 程序头部条目个数  */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Elf32_Half&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;e_shentsize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;            &lt;span class=&quot;cm&quot;&gt;/* 节头部中一个条目的长度 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Elf32_Half&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;e_shnum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                &lt;span class=&quot;cm&quot;&gt;/* 节头部条目个数 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Elf32_Half&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;e_shstrndx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;             &lt;span class=&quot;cm&quot;&gt;/* 节头部字符表索引 */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Elf32_Ehdr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面我们对ELF头表中一些重要的字段作出相关说明，完整的ELF定义请参阅参考资料 6和参考资料7。&lt;/p&gt;

&lt;p&gt;e_ident[0]-e_ident[3] 包含了ELF文件的魔数，依次是0x7f、’E’、’L’、’F’。注意，任何一个ELF文件必须包含此魔数。参考资料3中讨论了利用程序、工具、 /Proc文件系统等多种查看ELF魔数的方法。e_ident[4]表示硬件系统的位数，1代表32位，2代表64位。e_ident[5]表示数据编 码方式，1代表小印第安排序（最大有意义的字节占有最低的地址），2代表大印第安排序（最大有意义的字节占有最高的地址）。e_ident[6]指定 ELF头部的版本，当前必须为1。e_ident[7]到e_ident[14]是填充符，通常是0。ELF格式规范中定义这几个字节是被忽略的，但实际 上是这几个字节完全可以可被利用。如病毒Lin/Glaurung.676/666（参考资料1）设置e_ident[7]为0x21,表示本文件已被感染；或者存放可执行代码（参考资料2）。ELF头部中大多数字段都是对子头部数据的描述，其意义相对比较简单。值得注意的是某些病毒可能修改字段e_entry（程序进入点）的值，以指向病毒代码，例如上面提到的病毒Lin/Glaurung.676/666。&lt;/p&gt;

&lt;p&gt;一个实际可执行文件的文件头部形式如下：（利用命令readelf）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   ELF Header:
   Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
   Class:                             ELF32
   Data:                              2&lt;span class=&quot;s1&quot;&gt;&#39;s complement, little endian
   Version:                           1 (current)
   OS/ABI:                            UNIX - System V
   ABI Version:                       0
   Type:                              EXEC (Executable file)
   Machine:                           Intel 80386
   Version:                           0x1
   Entry point address:               0x80483cc
   Start of program headers:          52 (bytes into file)
   Start of section headers:          14936 (bytes into file)
   Flags:                             0x0
   Size of this header:               52 (bytes)
   Size of program headers:           32 (bytes)
   Number of program headers:         6
   Size of section headers:           40 (bytes)
   Number of section headers:         34
   Section header string table index: 31
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;紧接ELF头部的是程序头表，它是一个结构数组，包含了ELF头表中字段e_phnum定义的条目，结构描述一个段或其他系统准备执行该程序所需要的信息。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;Elf32_Word&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;p_type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* 段类型 */&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;Elf32_Off&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;p_offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;cm&quot;&gt;/* 段位置相对于文件开始处的偏移量 */&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;Elf32_Addr&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;p_vaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;cm&quot;&gt;/* 段在内存中的地址 */&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;Elf32_Addr&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;p_paddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;cm&quot;&gt;/* 段的物理地址 */&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;Elf32_Word&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;p_filesz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* 段在文件中的长度 */&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;Elf32_Word&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;p_memsz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* 段在内存中的长度 */&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;Elf32_Word&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;p_flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* 段的标记 */&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;Elf32_Word&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;p_align&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* 段在内存中对齐标记 */&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Elf32_Phdr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在详细讨论可执行文件程序头表之前，首先查看一个实际文件的输出：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Program Headers:
Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
PHDR           0x000034 0x08048034 0x08048034 0x000c0 0x000c0 R E 0x4
INTERP         0x0000f4 0x080480f4 0x080480f4 0x00013 0x00013 R   0x1
      &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Requesting program interpreter: /lib/ld-linux.so.2]
   LOAD           0x000000 0x08048000 0x08048000 0x00684 0x00684 R E 0x1000
   LOAD           0x000684 0x08049684 0x08049684 0x00118 0x00130 RW  0x1000
   DYNAMIC        0x000690 0x08049690 0x08049690 0x000c8 0x000c8 RW  0x4
   NOTE           0x000108 0x08048108 0x08048108 0x00020 0x00020 R   0x4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Section to Segment mapping:
  Segment Sections...
   00
   01     .interp
   02     .interp .note.ABI-tag .hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame
   03     .data .dynamic .ctors .dtors .jcr .got .bss
   04     .dynamic
   05     .note.ABI-tag
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Section Headers:
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; 0]                   NULL            00000000 000000 000000 00      0   0  0
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; 1] .interp           PROGBITS        080480f4 0000f4 000013 00   A  0   0  1
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; 2] .note.ABI-tag     NOTE            08048108 000108 000020 00   A  0   0  4
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; 3] .hash             HASH            08048128 000128 000040 04   A  4   0  4
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; 4] .dynsym           DYNSYM          08048168 000168 0000b0 10   A  5   1  4
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; 5] .dynstr           STRTAB          08048218 000218 00007b 00   A  0   0  1
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; 6] .gnu.version      VERSYM          08048294 000294 000016 02   A  4   0  2
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; 7] .gnu.version_r    VERNEED         080482ac 0002ac 000030 00   A  5   1  4
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; 8] .rel.dyn          REL             080482dc 0002dc 000008 08   A  4   0  4
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; 9] .rel.plt          REL             080482e4 0002e4 000040 08   A  4   b  4
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;10] .init             PROGBITS        08048324 000324 000017 00  AX  0   0  4
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;11] .plt              PROGBITS        0804833c 00033c 000090 04  AX  0   0  4
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;12] .text             PROGBITS        080483cc 0003cc 0001f8 00  AX  0   0  4
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;13] .fini             PROGBITS        080485c4 0005c4 00001b 00  AX  0   0  4
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;14] .rodata           PROGBITS        080485e0 0005e0 00009f 00   A  0   0 32
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;15] .eh_frame         PROGBITS        08048680 000680 000004 00   A  0   0  4
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;16] .data             PROGBITS        08049684 000684 00000c 00  WA  0   0  4
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;17] .dynamic          DYNAMIC         08049690 000690 0000c8 08  WA  5   0  4
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;18] .ctors            PROGBITS        08049758 000758 000008 00  WA  0   0  4
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;19] .dtors            PROGBITS        08049760 000760 000008 00  WA  0   0  4
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;20] .jcr              PROGBITS        08049768 000768 000004 00  WA  0   0  4
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;21] .got              PROGBITS        0804976c 00076c 000030 04  WA  0   0  4
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;22] .bss              NOBITS          0804979c 00079c 000018 00  WA  0   0  4
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;23] .comment          PROGBITS        00000000 00079c 000132 00      0   0  1
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;24] .debug_aranges    PROGBITS        00000000 0008d0 000098 00      0   0  8
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;25] .debug_pubnames   PROGBITS        00000000 000968 000040 00      0   0  1
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;26] .debug_info       PROGBITS        00000000 0009a8 001cc6 00      0   0  1
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;27] .debug_abbrev     PROGBITS        00000000 00266e 0002cc 00      0   0  1
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;28] .debug_line       PROGBITS        00000000 00293a 0003dc 00      0   0  1
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;29] .debug_frame      PROGBITS        00000000 002d18 000048 00      0   0  4
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;30] .debug_str        PROGBITS        00000000 002d60 000bcd 01  MS  0   0  1
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;31] .shstrtab         STRTAB          00000000 00392d 00012b 00      0   0  1
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;32] .symtab           SYMTAB          00000000 003fa8 000740 10     33  56  4
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;33] .strtab           STRTAB          00000000 0046e8 000467 00      0   0  1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对 一个ELF可执行程序而言，一个基本的段是标记p_type为PT_INTERP的段，它表明了运行此程序所需要的程序解释器（/lib/ld- linux.so.2），实际上也就是动态连接器（dynamiclinker）。最重要的段是标记p_type为PT_LOAD的段，它表明了为运行程 序而需要加载到内存的数据。查看上面实际输入，可以看见有两个可LOAD段，第一个为只读可执行（FLg为RE）,第二个为可读可写（Flg为RW）。段 1包含了文本节.text，注意到ELF文件头部中程序进入点的值为0x80483cc，正好是指向节.text在内存中的地址。段二包含了数据 节.data，此数据节中数据是可读可写的，相对的只读数据节.rodata包含在段1中。ELF格式可以比COFF格式包含更多的调试信息，如上面所列 出的形式为.debug_xxx的节。在I386平台LINUX系统下，用命令file查看一个ELF可执行程序的可能输出是：a.out: ELF 32-bit LSB executable, Intel 80386, version 1(SYSV), for GNU/Linux 2.2.5, dynamically linked (uses shared libs), notstripped。&lt;/p&gt;

&lt;p&gt;ELF文件中包含了动态连接器的全路径，内核定位”正确”的动态连接器在内存中的地址是”正确”运行可执行文件的保证，参考资料 13讨论了如何通过查找动态连接器在内存中的地址以达到颠覆（Subversiver）动态连接机制的方法。&lt;/p&gt;

&lt;p&gt;最 后我们讨论ELF文件的动态连接机制。每一个外部定义的符号在全局偏移表(Global Offset Table GOT)中有相应的条目,如果符号是函数则在过程连接表(Procedure Linkage TablePLT)中也有相应的条目，且一个PLT条目对应一个GOT条目。对外部定义函数解析可能是整个ELF文件规范中最复杂的，下面是函数符号解析 过程的一个描述。&lt;/p&gt;

&lt;p&gt;1：代码中调用外部函数func,语句形式为call 0xaabbccdd,地址0xaabbccdd实际上就是符号func在PLT表中对应的条目地址（假设地址为标号.PLT2）。&lt;/p&gt;

&lt;p&gt;2：PLT表的形式如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.PLT0: pushl   4&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;%ebx&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;    /&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; GOT表的地址保存在寄存器ebx中 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;/
       jmp     &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;8&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;%ebx&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
       nop; nop
       nop; nop
.PLT1: jmp     &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;name1@GOT&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;%ebx&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
       pushl   &lt;span class=&quot;nv&quot;&gt;$offset&lt;/span&gt;
       jmp     .PLT0@PC
.PLT2: jmp     &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;func@GOT&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;%ebx&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
       pushl   &lt;span class=&quot;nv&quot;&gt;$offset&lt;/span&gt;
       jmp     .PLT0@PC
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3：查看标号.PLT2的语句,实际上是跳转到符号func在GOT表中对应的条目。&lt;/p&gt;

&lt;p&gt;4：在符号没有重定位前，GOT表中此符号对应的地址为标号.PLT2的下一条语句，即是pushl $offset，其中$offset是符号func的重定位偏移量。注意到这是一个二次跳转。&lt;/p&gt;

&lt;p&gt;5：在符号func的重定位偏移量压栈后,控制跳到PLT表的第一条目，把GOT[1]的内容压栈，并跳转到GOT[2]对应的地址。&lt;/p&gt;

&lt;p&gt;6：GOT[2]对应的实际上是动态符号解析函数的代码，在对符号func的地址解析后，会把func在内存中的地址设置到GOT表中此符号对应的条目中。&lt;/p&gt;

&lt;p&gt;7：当第二次调用此符号时，GOT表中对应的条目已经包含了此符号的地址，就可直接调用而不需要利用PLT表进行跳转。&lt;/p&gt;

&lt;p&gt;动态连接是比较复杂的，但为了获得灵活性的代价通常就是复杂性。其最终目的是把GOT表中条目的值修改为符号的真实地址，这也可解释节.got包含在可读可写段中。&lt;/p&gt;

&lt;p&gt;动 态连接是一个非常重要的进步，这意味着库文件可以被升级、移动到其他目录等等而不需要重新编译程序（当然，这不意味库可以任意修改，如函数入参的个数、数 据类型应保持兼容性）。从很大程度上说，动态连接机制是ELF格式代替a.out格式的决定性原因。如果说面对对象的编程本质是面对接口 （interface）的编程，那么动态连接机制则是这种思想的地一个非常典型的应用，具体的讲，动态连接机制与设计模式中的桥接（BRIDGE）方法比 较类似，而它的LAZY特性则与代理（PROXY）方法非常相似。动态连接操作的细节描述请参阅参考资料 8，9，10，11。通过阅读命令readelf、objdump 的源代码以及参考资料14中所提及的相关软件源代码，可以对ELF文件的格式有更彻底的了解。&lt;/p&gt;

&lt;p&gt;总结
不同时期的可执行文件格式深刻的反映了技术进步的过程，技术进 步通常是针对解决存在的问题和适应新的环境。早期的UNIX系统使用a.out格式，随着操作系统和硬件系统的进步，a.out格式的局限性越来越明显。 新的可执行文件格式COFF在UNIX System VR3中出现，COFF格式相对a.out格式最大变化是多了一个节头表（section headtable），能够在包含基础的文本段、数据段、BSS段之外包含更多的段，但是COFF对动态连接和C++程序的支持仍然比较困难。为了解决上 述问题，UNIX系统实验室(UNIX SYSTEM Laboratories USL)开发出ELF文件格式，它被作为应用程序二进制接口（Application binary InterfaceABI）的一部分，其目的是替代传统的a.out格式。例如，ELF文件格式中引入初始化段.init和结束段.fini（分别对应构 造函数和析构函数）则主要是为了支持C++程序。1994年6月ELF格式出现在LINUX系统上，现在ELF格式作为UNIX/LINUX最主要的可执 行文件格式。当然我们完全有理由相信，在将来还会有新的可执行文件格式出现。&lt;/p&gt;

&lt;p&gt;上 述三种可执行文件格式都很好的体现了设计思想中分层的概念，由一个总的头部刻画了文件的基本要素，再由若干子头部/条目刻画了文件的若干细节。比较一下可 执行文件格式和以太数据包中以太头、IP头、TCP头的设计，我想我们能很好的感受分层这一重要的设计思想。参考资料 21从全局的角度讨论了各种文件的格式，并提出一个比较夸张的结论：Everything Is Byte!&lt;/p&gt;

&lt;p&gt;最后的题外话：大多数资料中对a.out格式的评价较低，常见的词语有黑暗年代（darkages）、丑陋（ugly）等等，当然，从现代的观点来看，的确是比较简单，但是如果没有曾经的简单何来今天的精巧？正如我们今天可以评价石器时代的技术是ugly,那么将来的人们也可以嘲讽今天的技术是非常ugly。我想我们也许应该用更平和的心态来对曾经的技术有一个公正的评价。&lt;/p&gt;
</description>
        <pubDate>Thu, 17 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://amazingw.github.com/2016/03/17/linux-file-system.html</link>
        <guid isPermaLink="true">http://amazingw.github.com/2016/03/17/linux-file-system.html</guid>
        
        <category>linux</category>
        
        
        <category>服务端开发</category>
        
      </item>
    
      <item>
        <title>游戏开发须知</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;. 1.函数体运行的时间大于函数调用所需的时间。这是由于参数压入和弹出堆栈造成的。在这种情况下，更好的方法可能是创建一个全局变量，然后在调用前进行赋值&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;. 2.尽量使用32位变量而不用8位变量或16位变量，Pentium和之后的处理器全部都是32位的，这就意味着它们并不喜欢8位或16位的数据字符，实际上，更小的数据可能会由于超高速缓存和其他相关的内存寻址异常而使速度下降&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;. 3.如果真想稳妥地话，应当将所有的结构都变为32字节的倍数。由于Pentium家庭处理器芯片上标准缓存线长度是32倍数，因而这是一个最佳长度，浪费内存但是提高运行速度。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;. 4.更多的使用简单指令，这样会使计算机使用更多的处理单元并行的处理程序。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;. 5.优化代码时候，乘法尽量使用移位算法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;. 6.视频游戏编程90%都是数据操作，游戏程序的数据应尽可能简单、可见，以便能够迅速地存取它、随意操作它或进行其他处理，确保你的数据结构按照这一原则进行处理。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;. 7.游戏设计中避免多重隶属关系。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;. 8.制定规范时,在开始你的游戏项目之前，进行一下组织工作，使用合理的文件名和目录名，提出一种一致的变量命名约定，尽量对图形和声音数据使用分开的目录，而不是将其全部都放置在一个目录中&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Thu, 17 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://amazingw.github.com/2016/03/17/knowledge-of-game-developper.html</link>
        <guid isPermaLink="true">http://amazingw.github.com/2016/03/17/knowledge-of-game-developper.html</guid>
        
        <category>游戏开发</category>
        
        
        <category>服务端开发</category>
        
      </item>
    
      <item>
        <title>游戏设计规范要求</title>
        <description>&lt;p&gt;由于采用游戏引擎为unity3d，固在游戏设计方面主要着重于对算法篇的要求&lt;/p&gt;

&lt;p&gt;代码规范：&lt;/p&gt;

&lt;p&gt;类行数要求：低于500行
代码方法行数要求：低于80行。
引包规范，所有包都放在util文件夹中&lt;/p&gt;

&lt;p&gt;命名规范，变量用驼峰命名法则，getModel，方法首字母大写
文件夹统一小写&lt;/p&gt;

&lt;p&gt;变量使用规范：
凡是有可能超过int32最大值的数，例如时间类型，全部使用long对于不存在负数类型的数，都采用unsigned long， 统一用宏定义为UINT64 INT64等
对于不存在负数的int，统一用unsigned int,不允许由于变量过小，而去采用byte等，只允许使用bool。32位cpu存储规范。&lt;/p&gt;

&lt;p&gt;类内单次使用数据结构，统一用struct，不允许用class，对于可能被统一调用的数据，采用class存储&lt;/p&gt;

&lt;p&gt;由于协议内不存在json等结构，不允许使用反射等消耗过大的内容&lt;/p&gt;

&lt;p&gt;算法设计要求：
多于50次循环需要提交讨论，不允许在设计中存在双重循环，程序内原则上不允许递归。数据结构选择优先级：数组&amp;gt;list&amp;gt;set&amp;gt;dic。&lt;/p&gt;

&lt;p&gt;代码注释要求：
每个类需要注释，方法有时间则写，没时间可避免。
文档用功能分类，游戏数据结构一旦建立，变更需要结合游戏需求。&lt;/p&gt;

&lt;p&gt;协议要求：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a.description(object);

sendTo&lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt; a&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;sendTo&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;sendTo&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;i=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;0;i&amp;lt;n;i++)&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;sendTo&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;sendTo&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;sendToEnd&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;协议封装要求：&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Proto&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;getPlayerName&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;version:内部版本
code:协议是否正常(exception 用3位连数 ，999为最严重异常，负数为系统级别以及外挂级别异常，0代表正常)
msgID:游戏设计中唯一的消息ID   通过 ,IDGenertor.GeneratorID()生成&lt;/p&gt;

&lt;p&gt;协议数据结构以：为分割。匹配客户端及服务端：
默认必须传得数据结构：
server:
//version:2,code:3,msgID:1 content:内容 time:serverTime
client:
//version:2,msgID:9
content: Proto. getPlayerName&lt;/p&gt;
</description>
        <pubDate>Thu, 17 Mar 2016 00:00:00 +0800</pubDate>
        <link>http://amazingw.github.com/2016/03/17/game-developper-code-desing.html</link>
        <guid isPermaLink="true">http://amazingw.github.com/2016/03/17/game-developper-code-desing.html</guid>
        
        <category>规范</category>
        
        <category>设计</category>
        
        <category>开发</category>
        
        <category>游戏</category>
        
        
        <category>服务端开发</category>
        
      </item>
    
  </channel>
</rss>
